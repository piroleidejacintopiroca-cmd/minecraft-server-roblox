


--[Settings]

---- Generation
if game["Run Service"]:IsStudio() then
	workspace.WorldInfo.ViewDistance.Value = 3
end
local gen_notrees = false
local gen_flat = false
local gen_air_ores = false
local blockdata1 = {}

--[Constants]
---- World constants
local TPS = 17
local b_size = 3
local heightlimit = workspace.WorldInfo.HeightLimit.Value
local viewdistance = workspace.WorldInfo.ViewDistance.Value
local waterLevel = 47
--local mapseed = ((os.time()/300 + os.clock())*7000)%7000 * 10
local SpawnPoints = game.ReplicatedStorage.SpawnPoints
local mapseed = math.random(1,1000000)
print("Seed:"..mapseed)
local maxquery = 750

---- Services
local S_PS = game:GetService("PhysicsService")
local S_H = game:GetService("HttpService")
local S_RS = game:GetService("RunService")
local S_ReS = game.ReplicatedStorage
terrain = require(script.Parent.Terrain.MinecraftTerrain)
if game["Run Service"]:IsStudio() then
end
game.ReplicatedStorage.TeleportSingleplayer.OnServerEvent:Connect(function(e)
	local Players = game:GetService("Players")
	local TeleportService = game:GetService("TeleportService")

	local function handleFailedTeleport(player, teleportResult, errorMessage, targetPlaceId, teleportOptions)
		if teleportResult == Enum.TeleportResult.Flooded or teleportResult == Enum.TeleportResult.Failure then
			-- pause and retry if it's a one-time hiccup
			task.wait(2)
			-- teleportOptions automatically have the reservedServerCode filled up
			TeleportService:TeleportAsync(targetPlaceId, {player}, teleportOptions)
		else
			-- throw an error if something else is wrong
			error(("Invalid teleport [%s]: %s"):format(teleportResult.Name, errorMessage))
		end
	end

	TeleportService.TeleportInitFailed:Connect(handleFailedTeleport)

	-- teleport all players to a reserved server
	local teleportOptions = Instance.new("TeleportOptions")
	teleportOptions.ShouldReserveServer = true
	TeleportService:TeleportAsync(game.PlaceId, {e}, teleportOptions)
end)

game.ReplicatedStorage.PressedButton.OnServerEvent:Connect(function(plr)
	local pressedbutton = Instance.new("StringValue")
	pressedbutton.Parent = plr
	pressedbutton.Name = "pressedbutton"
	pressedbutton.Value = "Pressed"
end)
---- ID Info
local function getServerType()
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "VIPServer"
		else
			return "ReservedServer"
		end
	else
		return "StandardServer"
	end
end


local idinfo = require(S_ReS:WaitForChild("IDInfo"))

---- Sound Info
local soundinfo = require(S_ReS:WaitForChild("SoundInfo"))

---- Recipes
local recipes = require(S_ReS:WaitForChild("Recipes"))

---- Smelting Recipes
local smeltrecipes = require(S_ReS:WaitForChild("SmeltRecipes"))

---- ID references
local lavaid = {
	[10] = true,[11] = true
}
local waterid = {
	[8] = true,[9] = true

}
local nocaveid = {
	[0] = true,[7] = true,[8] = true,[9] = true,[10] = true,[11] = true
}
local leavesid = {
	[18] = true,
	[126] = true
}

local transparentid = {}
local nonsolidid = {}
local fluidid = {}
for i,v in pairs(idinfo) do
	if v.transparent then
		transparentid[i] = true
	end
	if v.fluid then
		fluidid[i] = true
	end
	if v.nonsolid then
		nonsolidid[i] = true
	end
end

---- Harvest

local drop_silktouch = {
	[1] = 4,
	[2] = 3,
	[346] = 3,
	[358] = 3,
	[127] = 3,

	[16] = 263,
	[18] = {
		{1/20,6,1},
		{1/50,280,2},
		{1/200,260,1},
	},
	[20] = 0,
	[347] = 0,
	[360] = 0,
	[356] = 0,
	[357] = 280,
	[340] = 3,
	[56] = 264,
	[119] = 120,
}
local drop_any = {
	[31] = {
		{2/15,295,1},
	},
	[359] = {
		{2/15,295,1},
	},
	[351] = {
		{2/15,295,1},
	},
	--351
	[352] = 0,
	[51] = 0,
	[60] = 3,
	[90] = 0,
}

---- Direction

local vecdir = { -- In CCW
	Vector3.new(0,0,-1),
	Vector3.new(-1,0,0),
	Vector3.new(0,0,1),
	Vector3.new(1,0,0),
	Vector3.new(0,1,0),
	Vector3.new(0,-1,0),
}
local vecdirnames = {
	"north","west","south","east","top","bottom"
}

---- Misc

local sinceStart = os.time()

--[Resources]

---- Chunks
local chunk = {}
chunk.__index = chunk

local loadedChunks = {
	overworld = {}, nether = {}
}

local needChunks = {
	overworld = {}, nether = {}
}

---- Tickets
local ticket = {}
ticket.__index = ticket

---- Entities
local entity = require(script:WaitForChild("EntityModule"))

---- Players
local playerinfo = {}

---- Null mapper
local blockdef = {}
blockdef.__index = function(t,i)
	if i == "id" then
		return 0
	end
end

--[Variables]

---- State query list (action/variable)
local statequery = {}

---- Tickets
local tickets = {
	overworld = {}, nether = {}
}
local genTickets = {
	overworld = {}, nether = {}
}

---- World
overworld = {}
nether = {}

local ticks = 0

---- Pre-Metadata
local structures = {
	overworld = {}, nether = {}
}
local caves = {
	overworld = {}, nether = {}
}
local ores = {
	overworld = {}, nether = {}
}

---- Block updates
local blockupdates = {
	overworld = {}, nether = {}
}
local liquidticks = {
	overworld = {}, nether = {}
}
local scheduledupdates = {
	overworld = {}, nether = {}
}
local blocksets = {
	overworld = {}, nether = {}
}
local tileentsets = {
	overworld = {}, nether = {}
}

---- Weather
local lastWeather = 0
local weatherTransition = 0

local ticksBeforeWeather = nil

---- Misc
local etst = 0
local pendingEvents = {
	overworld = {}
}
local updatedEnt = {
	overworld = {}
}
local entchunks = {}
local dmgreq = {}
local tickRan = Random.new(mapseed)

local lastEntities = {}


--[General functions]

function deepcopy(orig, copies)
	copies = copies or {}
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		if copies[orig] then
			copy = copies[orig]
		else
			copy = {}
			copies[orig] = copy
			for orig_key, orig_value in next, orig, nil do
				copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)
			end
			setmetatable(copy, deepcopy(getmetatable(orig), copies))
		end
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

function lerp(a,b,t)
	return a + t * (b - a)
end
local biomeSizeMin = 4 -- Minimum biome size in chunks
local biomeSizeMax = 10 -- Maximum biome size in chunks

local isSandBiome = false -- Initialize as not in a sand biome
function getSlotContent(slot)
	if slot then
		local id = slot.id
		if id == 0 then
			id = nil
		end
		local count = id and slot.Count or 0
		return {count,(count > 0) and id}
	else
		return {0}
	end		
end

function indexVector(t,x,y,z,val,tr)
	if x>=0 and x<16 and z>=0 and z<16 and y>=0 and y<(heightlimit) then
		if val then
			t[x + z*16 + y*256] = val
			return val
		else
			return t[x + z*16 + y*256]
		end
	end
end

function indexVector1(t,x,y,z,tr)
	if x>=0 and x<16 and z>=0 and z<16 and y>=0 and y<(heightlimit) then
		if not tr then
		else
			print(t[x + z*16 + y*256])
			print(t)
			print(x)
			print(y)
			print(z)
			return t[x + z*16 + y*256]
		end
	end
end


function indexVectorReplace(t,x,y,z,val)
	if x>=0 and x<16 and z>=0 and z<16 and y>=0 and y<(heightlimit) then
		t[x + z*16 + y*256] = val
		return val
	end
end

function canHarvest(tool,bid)
	local toolspeed = 1
	local speed = 1
	local binfo = idinfo[bid]

	local toolinfo = tool and idinfo[tool.id]
	if toolinfo then
		local c = {
			["wood"] = 2,
			["stone"] = 4,
			["iron"] = 6,
			["diamond"] = 8,
			["gold"] = 12,
		}

		toolspeed = c[toolinfo.material] or 1
	end

	local damage = 0

	if toolinfo and toolinfo.tool then
		damage = 1
		if (toolinfo.type == "shovel") or (toolinfo.type == "axe") or (toolinfo.type == "pickaxe") then
			damage = (binfo.hardness ~= 0) and 1 or 0
		elseif toolinfo.type == "sword" then
			damage = (binfo.hardness ~= 0) and 2 or 0
			toolspeed *= 1.5
			if bid == 30 then
				toolspeed *= 1.5
			end
		elseif toolinfo.type == "farmingtool" then
			damage = 0
		elseif tool.id == 359 then
			--if then -- for Wool Blocks

			if bid == 18 then
				toolspeed *= 15
			end
			if (bid == 18) or (bid == 30) or (bid == 31) or (bid == 351) or (bid == 356) or (bid == 359) or (bid == 347) or (bid == 360) then
				damage = 1
			else
				damage = 0
			end
		end
	end

	if binfo.toolonly then
		if toolinfo then
			if table.find(binfo.tools,toolinfo.type) then -- Type of tool that can harvest
				speed *= toolspeed
				if not binfo.toolmaterial then -- Does not require material
					return true,speed,damage
				else
					if table.find(binfo.toolmaterial,toolinfo.material) then -- Does require material
						return true,speed,damage
					else
						return false,speed,damage
					end
				end
			end
		end
	else
		if binfo.tools and toolinfo then
			if table.find(binfo.tools,toolinfo.type) then
				speed *= toolspeed
				return true,speed,damage
			end
		end
		return true,speed,damage
	end
	return false,speed,damage
end

function getBlock(x,y,z,d)
	local c = getChunk(math.floor(x/16),math.floor(z/16),d)
	return c and c.blockdata and indexVector(c.blockdata,x%16,y,z%16),c
end

function getBlockForCC(x,y,z,d)
	local c = getChunk(math.floor(x/16),math.floor(z/16),d)
	local b = c and c.blockdata and indexVector(c.blockdata,x%16,y,z%16)
	local b2 = c and c.blockdata and indexVector(c.blockdata,x%16,y-1,z%16)
	return b,c,b2
end

function getPropData(x,y,z,d)
	local c = getChunk(math.floor(x/16),math.floor(z/16),d)
	return c and c.propdata and indexVector(c.propdata,x%16,y,z%16),c
end

function setBlock(x,y,z,i,d)
	local c = getChunk(math.floor(x/16),math.floor(z/16),d)
	if c and c.blockdata then
		c:Set(x%16,y,z%16,i,true)
	end
end

--function getBlockInfo(b)
--	if b then
--		if type(b) == "number" then
--			return {id = b}
--		else
--			return b
--		end
--	end
--end

--function getBlockID(t)
--	return t
--end

function isSolid(id)
	return id and (id ~= 0) and not (fluidid[id] or nonsolidid[id])
end

function PtoT(x,y,z)
	if type(x) == "vector" then
		x,y,z = x.X,x.Y,x.Z
	end
	return math.floor(x/b_size + .5),math.floor(y/b_size + .5),math.floor(z/b_size + .5)
end

function createEntity(pos,id,d)
	local ch = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)

	if ch and ch.loaded then
		local ent = entity.New(id)
		ent.Pos = pos

		table.insert(ch.entitydata,ent)

		entchunks[ent] = ch
		table.insert(updatedEnt[d or "overworld"],ent)

		return ent
	end
end

function attemptSpawn(id,num,pos,dimension)
	if not workspace.WorldDebug.Mobs.Value then
		return
	end
	local spawnable = id
	for p,v in pairs(playerinfo) do
		if p.Parent == game.Players then
			if game.Players:FindFirstChild(p.Name):FindFirstChild("pressedbutton") then
				if (v.Pos - pos).Magnitude < 24 then
					spawnable = false
					break
				elseif (not spawnable) and ((v.Pos - pos).Magnitude < 44) then
					spawnable = true
				end
			end
		end
	end
	for i,v in pairs(playerinfo)  do
		if i and i.Parent == game.Players then
             spawnable = true
break
		else
			spawnable = false
			break
		end
	end
	if playerinfo == {} then
		spawnable = false
	end
	if spawnable then
		for i=1,num do
			local cur = pos

			for i=1,4 do
				local r0,c = getBlock(cur.X,cur.Y,cur.Z,dimension)
				local b0 = r0
				if c and c.loaded and b0 and isSolid(b0) then
					local b1 = getBlock(cur.X,cur.Y+1,cur.Z,dimension)
					local b2 = getBlock(cur.X,cur.Y+2,cur.Z,dimension)
					if not (b1 and (b1 ~= 0) and b2 and (b2 ~= 0)) then
						local ent = createEntity(Vector3.new(cur.X + .5,cur.Y+1.5,cur.Z + .5),id,dimension)
						if ent then
							ent:Initialize()
						end
					end
					break
				end
				cur = Vector3.new(cur.X + math.random(-4,4),cur.Y,cur.Z + math.random(-4,4))
			end
		end
	end
end

-- Define your DataStore
local DataStoreService = game:GetService("DataStoreService")
local playerDataStore = DataStoreService:GetDataStore("PlayerDataStore")

-- Function to save player data
-- Function to save player data
local function savePlayerData(player)
	local plrent = playerinfo[player]
	if plrent then

		local playerData = {
			Pos = plrent.Pos,
			changeMotion = plrent.changeMotion,
			updateInventory = plrent.updateInventory,
			Player = player,
			UserId = player.UserId,
			Inventory = plrent.Inventory,

		}
		local jsonPlayerData = game:GetService("HttpService"):JSONEncode(playerData)

		local success, error = pcall(function()
			playerDataStore:SetAsync(tostring(player.UserId), jsonPlayerData)
		end)

		if success then
			----"Player data saved for player: " .. player.Name)
		else
			warn("Error saving player data for player: " .. player.Name, error)
		end
		--	playerinfo[player] = entity.New(nil)
	end
end
game.Players.PlayerRemoving:Connect(savePlayerData)

game.ReplicatedStorage.SpawnEntityRQ.Event:Connect(function(pos,typ,self)
	if pos and typ then
		local cur =pos
		local ent = createEntity(Vector3.new(cur.X ,cur.Y+1.5,cur.Z),typ or "xp","overworld")
		if ent then
			ent:Initialize(self)
		end
	end
end)

local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")

local purchaseHistoryStore = DataStoreService:GetDataStore("PurchaseHistory")

local productFunctions = {}

--Stone Sword [1]
productFunctions[1863415881] = function(receipt, plr)
		local plr1 = playerinfo[plr]
		if not plr1 then
			return
		end
		local dimesion = "overworld"
		local self = plr1
		local iteme = createEntity(plr1.Pos,"item","overworld")
		if iteme then
			iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
			iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
			iteme.Item = {
				Count = 1,
				id = 272
			}
			iteme.PickupDelay = 0
			iteme:Initialize()
	end
	return true
end

--Iron Sword [2]
productFunctions[1863415979] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 267
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true	
end

--Gold Sword [3]
productFunctions[1863416058] = function(receipt, plr)
		local plr1 = playerinfo[plr]
		if not plr1 then
			return
		end
		local dimesion = "overworld"
		local self = plr1
		local iteme = createEntity(plr1.Pos,"item","overworld")
		if iteme then
			iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
			iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
			iteme.Item = {
				Count = 1,
				id = 283
			}
			iteme.PickupDelay = 0
			iteme:Initialize()
	end
	return true
end

--Diamond Sword [4]
productFunctions[1769857997] = function(receipt, plr)
		local plr1 = playerinfo[plr]
		if not plr1 then
			return
		end
		local dimesion = "overworld"
		local self = plr1
		local iteme = createEntity(plr1.Pos,"item","overworld")
		if iteme then
			iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
			iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
			iteme.Item = {
				Count = 1,
				id = 276
			}
			iteme.PickupDelay = 0
			iteme:Initialize()
	end
	return true
end

--Stone Axe [5]
productFunctions[1863416214] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 275
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Axe [6]
productFunctions[1863416308] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 258
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Axe [7]
productFunctions[1863416432] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 286
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Axe [8]
productFunctions[1863416523] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 279
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Stone Pickaxe [9]
productFunctions[1863416655] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 274
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Pickaxe [10]
productFunctions[1863416718] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 257
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Pickaxe [11]
productFunctions[1863416785] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 285
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Pickaxe [12]
productFunctions[1863416868] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 278
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--32 Cobblestone [13]
productFunctions[1863416981] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 32,
			id = 4
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Ingot [14]
productFunctions[1863417337] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 265
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--32 OakPlanks [17]
productFunctions[1863417078] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 32,
			id = 5
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--32 Glass [18]
productFunctions[1863417149] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 32,
			id = 20
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--32 Torchs [19]
productFunctions[1863417225] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 32,
			id = 50
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Helmet [20]
productFunctions[1863417799] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 306
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Leggings [22]
productFunctions[1863418481] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 308
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Boots [23]
productFunctions[1863418759] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 309
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Helmet [24]
productFunctions[1863417929] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 314
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Chestplate [25]
productFunctions[1863418205] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 315
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Leggings [26]
productFunctions[1863418560] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 316
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Boots [27]
productFunctions[1863418828] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 317
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Helmet [18]
productFunctions[1863418026] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 310
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Chestplate [29]
productFunctions[1863418312] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 311
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Leggings [30]
productFunctions[1863418655] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 312
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond Boots [31]
productFunctions[1863418903] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 313
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Iron Chestplate [21]
productFunctions[1863418117] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 307
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Gold Ingot [15]
productFunctions[1863417445] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 266
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end

--Diamond [16]
productFunctions[1863417585] = function(receipt, plr)
	local plr1 = playerinfo[plr]
	if not plr1 then
		return
	end
	local dimesion = "overworld"
	local self = plr1
	local iteme = createEntity(plr1.Pos,"item","overworld")
	if iteme then
		iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
		iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
		iteme.Item = {
			Count = 1,
			id = 264
		}
		iteme.PickupDelay = 0
		iteme:Initialize()
	end
	return true
end


local function processReceipt(receiptInfo)

	local playerProductKey = receiptInfo.PlayerId .. "_" .. receiptInfo.PurchaseId
	local purchased = false
	local success, errorMessage = pcall(function()
		purchased = purchaseHistoryStore:GetAsync(playerProductKey)
	end)

	if success and purchased then
		return Enum.ProductPurchaseDecision.PurchaseGranted
	elseif not success then
		error("Data store error:" .. errorMessage)
	end


	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	local handler = productFunctions[receiptInfo.ProductId]


	local success, result = pcall(handler, receiptInfo, player)
	if not success or not result then
		warn("Error occurred while processing a product purchase")
		print("\nProductId:", receiptInfo.ProductId)
		print("\nPlayer:", player)
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end


	local success, errorMessage = pcall(function()
		purchaseHistoryStore:SetAsync(playerProductKey, true)
	end)
	if not success then
		error("Cannot save purchase data: " .. errorMessage)
	end


	return Enum.ProductPurchaseDecision.PurchaseGranted
end

MarketplaceService.ProcessReceipt = processReceipt

-- Function to load player data
game.ReplicatedStorage.UseCommand.OnServerEvent:Connect(function(plr,e)
	if  plr.Name == "Coolest_LSELFAVER" or plr.Name == "lselfaver696969" or plr.Name == "MinecraftUploader55" or plr.Name == "Eliasjr170" or plr.Name == "95kStudios" or plr.Name == "2ktgf6JF1GkTEeopui5"  or plr.Name == "URSHORTASHELLLOL" or plr.Name == "Player1" or plr.Name == "epiv66" then
		local g = string.split(e," ")
		local amount = 1
		local plr1 = playerinfo[plr]
		if not plr1 then
			return
		end
		local id1 = 49
		if g[1] == "/give" or g[1] == "/g" then
			if g[3] ~= nil then
				amount = tonumber(g[3])
			end
			if g[2] ~= nil then
				id1 = tonumber(g[2])
			end

			if g[4] ~= nil then
				plr1 = playerinfo[g[4]]
			end
			local name = ""
			local name = ""
			for i = 2, math.huge do
				if g[i] then
					if name ~= "" then
						name = name .. " "
					end
					name = name .. tostring(g[i])
					print(name)
				else
					break
				end
				wait()
			end

			for i,v in pairs(require(game.ReplicatedStorage.IDInfo)) do
				if v.name == tostring(name) then
					print("eyy")
					if v.stack then
						amount = v.stack
					else
						amount = 64
					end
					id1 = i
					print(id1)
					local dimesion = "overworld"
					local self = plr1
					local iteme = createEntity(plr1.Pos,"item","overworld")
					if iteme then
						iteme.Pos = Vector3.new(self.Pos.X,self.Pos.Y + .8,self.Pos.Z)
						iteme.Motion = CFrame.fromEulerAnglesYXZ(0.1,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
						iteme.Item = {
							Count = 64,
							id = i
						}
						iteme.PickupDelay = 0.05
						iteme:Initialize()
					end
					break
				end
			end

		end
		if g[1] == "/gm" or g[1] == "/gamemode" then

			if g[2] ~= nil then
				id1 = tonumber(g[2])
			end
			--id1)
			if id1 == 1 and plr1 then
				plr1.Health = math.huge
				plr.PlayerGui.MainGui.HUD.Hotbar.HealthBar.Visible = false
				plr.PlayerGui.MainGui.HUD.Hotbar.HungerBar.Visible = false
				if not plr.Character:FindFirstChild("Creative") then
					local e = Instance.new("BoolValue",plr.Character)
					e.Name = "Creative"
				end
				if not plr:FindFirstChild("Creative") then
					local e = Instance.new("BoolValue",plr)
					e.Name = "Creative"
				end
			else
				plr1.Health = 20
				plr.PlayerGui.MainGui.HUD.Hotbar.HealthBar.Visible = true
				plr.PlayerGui.MainGui.HUD.Hotbar.HungerBar.Visible = true
				if plr.Character:FindFirstChild("Creative") then
					plr.Character:FindFirstChild("Creative"):Destroy()
					plr.Character.Fly.Value = true
					wait(0.1)
					plr.Character.Fly.Value = false
				end
				if plr:FindFirstChild("Creative") then
					plr.Creative:Destroy()
				end
			end
			plr1.gamemode = id1 -- this dont seem to work
		end
		if g[1] == "/console" then
			game.ReplicatedStorage.ConsoleOpen:FireClient(plr)
		end
		if g[1] == "/tp" then
			local plr1 = nil


			if g[2] == "all" then
				for i,v in pairs(game.Players:GetPlayers()) do
					if playerinfo[v] then
						local e = playerinfo[v]
						spawn(function()
							e.Pos = playerinfo[plr].Pos
							wait()

						end)

					end
				end
			else
				plr1 = playerinfo[game.Players:WaitForChild(g[2])]
				plr1.Pos = playerinfo[plr].Pos
				wait()
			end
		end
		if g[1] == "/locate" then
			local plr1 = nil
			if g[2] ~= nil then
				plr1 = playerinfo[game.Players:WaitForChild(g[2])]
			end
			if plr1 ~= nil then
			end
			local function ServerMessage(message: string, target,nnmber,glden)
				local data = {
					Message = message,
					Name = "Server",
					Color = Color3.fromRGB(252, 216, 10),
					MessageColor = Color3.fromRGB(252, 216, 10)
				}
				game.ReplicatedStorage:WaitForChild("ChatEvents"):WaitForChild("MessageSent"):FireClient(plr,data)
			end
			ServerMessage(tostring(plr1.Pos),nil,false,false)
		end
		if g[1] == "/spawn" then
			local plr1 = nil
			local x,y,z = playerinfo[plr].Pos.X,playerinfo[plr].Pos.Y,playerinfo[plr].Pos.Z -- spawning mobs cuz why not
			--	attemptSpawn(g[2],math.random(1,3),Vector3.new(x,y,z))
			if g[2] == "tnt" then
				spawn(function()
					for i = 1,g[3] + 20 or 1 do
						playerinfo[plr].Health = 20
						wait()
					end
				end)
			end
			for i = 1,g[3] or 1  do
				local cur = playerinfo[plr].Pos
				local ent = createEntity(Vector3.new(cur.X + .5,cur.Y+1.5,cur.Z + .5),g[2],"overworld")
				if ent then
					ent:Initialize()
				end
				wait()
			end

		end
		if g[1] == "/portal" then
			local plr1 = nil
			--"spawn!!!")
			local x,y,z = playerinfo[plr].Pos.X,playerinfo[plr].Pos.Y,playerinfo[plr].Pos.Z -- spawning mobs cuz why not
			--	attemptSpawn(g[2],math.random(1,3),Vector3.new(x,y,z))
			-- theres no function
		end
		if g[1] == "/clear" then
			spawnPlayerDiff(plr)
		end
	else
		local g = string.split(e," ")
		if g[1] == "/clear" or g[1] == "/give" or g[1] == "/gm" or g[1] == "/tp" or g[1] == "/locate" or g[1] == "/spawn" or g[1] == "/portal" then
			local data = {Message = "You cannot use that command lol"}
			game.ReplicatedStorage:WaitForChild("ChatEvents"):WaitForChild("MessageSent"):FireClient(plr,data,0,false,"c")
		end
	end
end)
function spawnPlayer(plr)
	local x = math.random(-350, 350)
	local z = math.random(-350, 350)
	local c = getChunk(math.floor(x / 16), math.floor(z / 16))
	if c then
		local fy = 0

		for y = (heightlimit - 1), 0, -1 do
			local b = indexVector(c.blockdata, x % 16, y, z % 16)
			if (b and isSolid(b)) then
				fy = y + 1
				if fy < waterLevel then
					fy = waterLevel + 1
				end
				break
			end
		end

		-- Set a minimum y-coordinate
		local minY = 48  -- Adjust this value to your desired minimum y-coordinate

		if fy < minY then
			fy = minY
		end

		-- Spawn the player at the coordinates (x + 0.5, fy + 0.5, z + 0.5)

		local haspos = false
		local pos = playerinfo[plr]

		-- Check if player data exists in the DataStore based on UserID
		local playerData
		local success, error = pcall(function()
			playerData = playerDataStore:GetAsync(tostring(plr.UserId))
		end)

		local inv = false
		if success and playerData then
			playerData = game:GetService("HttpService"):JSONDecode(playerData)
			inv = true
		end
		if inv and playerinfo[plr] then
			playerinfo[plr].Pos = playerData.Pos
			haspos = true
			pos = playerData.Pos
		end
		playerinfo[plr] = entity.New(nil)
		if not plr:FindFirstChild("Hunger") then
			local Hunger = Instance.new("NumberValue")
			Hunger.Value = 100
			Hunger.Name = "Hunger"
			Hunger.Parent = plr
		else
			plr:FindFirstChild("Hunger"):Destroy()
			local Hunger = Instance.new("NumberValue")
			Hunger.Value = 100
			Hunger.Name = "Hunger"
			Hunger.Parent = plr
		end
		local plrent = playerinfo[plr]

		-- Set default values in case playerData is not present
		if haspos == false then
			plrent.Pos = Vector3.new(x + 0.5, fy + 0.5, z + 0.5)
		else
			plrent.Pos = pos
		end

		for i,v in pairs(SpawnPoints:GetChildren()) do
			if v.Name == plr.Name then
				plrent.Pos = v.Value
				break
			end
		end
		plrent.Player = plr
		plrent.UserId = plr.UserId
		plrent.changeMotion = true
		plrent.updateInventory = true
        game.ReplicatedStorage.UpdatePlayer:FireClient(plr,"Pos",plrent.Pos)
		plrent:Initialize()
		plr:LoadCharacter()
		if inv then
			-- Load the inventory here

			local inventoryData = playerData["Inventory"]

			if inventoryData then
				local plrinventory = plrent.Inventory
				for id, itemData in ipairs(inventoryData) do
					-- Create a new item entity
					local item = entity.New(nil)
					item.Count = itemData["Count"]
					item.Slot = itemData["Slot"]
					item.id = itemData["id"]

					-- Create and populate the "damage" tag
					item.tag = itemData["tag"] or {}

					plrinventory[id] = item
					plrent.Inventory[id] = item
				end
			end
			game.ReplicatedStorage.UpdatePlayer:FireClient(plr,"RenderInventory")

		end

		spawn(function()
			while wait(math.random(10,20)) do
				if game.Players:FindFirstChild(plr.Name) then
					local p = game.Players:FindFirstChild(plr.Name) 
					if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value ~= 0 and plrent.Health ~= math.huge then
						p.Hunger.Value = p.Hunger.Value - 1
					end
				end
			end
		end)

		spawn(function()
			while wait(math.random(3,7)) do
				if game.Players:FindFirstChild(plr.Name) then
					local p = game.Players:FindFirstChild(plr.Name) 
					if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value > 96 then
						if plrent then
							if plrent.Health < 20 then
								plrent.Health += 1
							end
						end
					end
				end
			end
		end)
		spawn(function()
			while wait(2) do
				if game.Players:FindFirstChild(plr.Name) then
					local p = game.Players:FindFirstChild(plr.Name) 
					if p:FindFirstChild("Hunger") then
						if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value == 0 then
							if plrent.Health ~= 0 then
								plrent.Health -= 1
							end
						end
					end
				end
			end
		end)
	end
end

function spawnPlayerDiff(plr)
	local x = math.random(-200, 200) -- not the Y axis
	local z = math.random(-200, 200) -- not the Y axis
	local c = getChunk(math.floor(x / 16), math.floor(z / 16))
	if c then
		spawn(function()
			local fy = 0
			for y = (heightlimit - 1), 0, -1 do
				local b = indexVector(c.blockdata, x % 16, y, z % 16)
				if (b and isSolid(b)) then
					fy = y + 1
					break
				end
			end

			-- Check if player data exists in the DataStore based on UserID
			local playerData
			local success, error = pcall(function()
				playerData = playerDataStore:GetAsync(tostring(plr.UserId))
			end)

			local inv = false
			if success and playerData then
				playerData = {}
				inv = false
			end

			playerinfo[plr] = entity.New(nil)

			local plrent = playerinfo[plr]

			-- Set default values in case playerData is not present
			plrent.Pos = Vector3.new(x + 0.5, fy + 0.5, z + 0.5)
			plrent.Player = plr
			plrent.FallDistance = 0
			plrent.UserId = plr.UserId
			plrent.changeMotion = true
			plrent.updateInventory = true
			Instance.new("BoolValue",plr.Character).Name = "Started"
			plr:LoadCharacter()
			plrent:Initialize()

			if inv then
				-- Load the inventory here
				local inventoryData = playerData["Inventory"]

				if inventoryData then
					local plrinventory = plrent.Inventory
					for id, itemData in ipairs(inventoryData) do
						-- Create a new item entity
						local item = entity.New(nil)
						item.Count = itemData["Count"]
						item.Slot = itemData["Slot"]
						item.id = itemData["id"]

						-- Create and populate the "damage" tag
						item.tag = itemData["tag"] or {}

						plrinventory[id] = item
						plrent.Inventory[id] = item
					end
				end
				game.ReplicatedStorage.UpdatePlayer:FireClient(plr,"RenderInventory")

			end
			spawn(function()
				while wait(math.random(10,20)) do
					if game.Players:FindFirstChild(plr.Name) then
						local p = game.Players:FindFirstChild(plr.Name) 
						if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value ~= 0 and plrent.Health ~= math.huge then
							p.Hunger.Value = p.Hunger.Value - 1
						end
					end
				end
			end)

			spawn(function()
				while wait(math.random(3,7)) do
					if game.Players:FindFirstChild(plr.Name) then
						local p = game.Players:FindFirstChild(plr.Name) 
						if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value > 96 then
							if plrent then
								if plrent.Health < 20 then
									plrent.Health += 1
								end
							end
						end
					end
				end
			end)
			spawn(function()
				while wait(2) do
					if game.Players:FindFirstChild(plr.Name) then
						local p = game.Players:FindFirstChild(plr.Name) 
						if p:FindFirstChild("Hunger") then
							if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value == 0 then
								if plrent.Health ~= 0 then
									plrent.Health -= 1
								end
							end
						end
					end
				end
			end)

		end)
	end
end
function spawnPlayerDifferent(plr) -- when dying
	local x = math.random(-20, 20)
	local z = math.random(-20, 20)
	local c = getChunk(math.floor(x / 16), math.floor(z / 16))
	if c then
		spawn(function()
			--	plr:LoadCharacter()
			local fy = 0
			for y = (heightlimit - 1), 0, -1 do
				local b = indexVector(c.blockdata, x % 16, y, z % 16)
				if (b and isSolid(b)) then
					fy = y + 1
					break
				end
			end


			playerinfo[plr] = entity.New(nil)

			local plrent = playerinfo[plr]

			plrent.Pos = Vector3.new(x + 0.5, fy + 0.5, z + 0.5)
			plrent.Player = plr
			plrent.UserId = plr.UserId
			plrent.changeMotion =  true
			plrent.updateInventory =  true
			plrent:Initialize()
			spawn(function()
				while wait(math.random(10,20)) do
					if game.Players:FindFirstChild(plr.Name) then
						local p = game.Players:FindFirstChild(plr.Name) 
						if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value ~= 0 then
							p.Hunger.Value = p.Hunger.Value - 1
						end
					end
				end
			end)
			spawn(function()
				while wait(2) do
					if game.Players:FindFirstChild(plr.Name) then
						local p = game.Players:FindFirstChild(plr.Name) 
						if p:FindFirstChild("Hunger") then
							if p:FindFirstChild("Hunger") and p:FindFirstChild("Hunger").Value == 0 then
								if plrent.Health ~= 0 then
									plrent.Health -= 1
								end
							end
						end
					end
				end
			end)
		end)
	end
end
-- Connect the "loadPlayerData" function to the player's spawn event

-- Connect the "savePlayerData" function to the player's leaving event

function getNearbyEntities(pos,d)
	local d = d or 0
	local cx = pos.X/16
	local cy = pos.Z/16
	local ents = {}
	for x=math.floor(cx-.25),math.floor(cx+.25) do
		for y=math.floor(cy-.25),math.floor(cy+.25) do
			if getTicket(x,y,d) < 32 then
				local c = getChunk(x,y,d)
				if c and c.loaded then
					for _,v in pairs(c.entitydata) do
						table.insert(ents,v)
					end
				end
			end
		end
	end
	for _,v in pairs(playerinfo) do
		if v.Dimension == d then
			table.insert(ents,v)
		end
	end
	return ents
end

function createExplosion(pos,power,drop,d)
	addEvent(d,"explosion",pos)
	local x0,y0,z0 = pos.X,pos.Y,pos.Z

	-- Entities
	local ents = getNearbyEntities(pos,d)
	for _,v in pairs(ents) do
		local dist = (v.Pos - pos).Magnitude
		if dist < (2*power) then
			local impact = (1 - dist/(2*power)) * 1
			if v.Player then
				local impact = (1 - dist/(2*power)) * 1
				requestDamage(v.UUID or v.Player,"blast",math.floor((impact^2 + impact)*7*power+1))
				game.ReplicatedStorage.Adder:FireClient(game.Players:WaitForChild(v.Player.Name),(v.Pos - pos).Unit * 1 * Vector3.new(0,3,0))
			else
				local impact = (1 - dist/(2*power)) * 1
				requestDamage(v.UUID or v.Player,"blast",math.floor((impact^2 + impact)*7*power+1))
			end
		end
	end

	-- Blocks
	local function castRay(x,y,z)
		local int = (.7 + math.random()*.6) * power
		local mag = math.sqrt(x^2 + y^2 + z^2)
		local x2,y2,z2 = x/mag*.3,y/mag*.3,z/mag*.3
		local x3,y3,z3 = x2,y2,z2
		while int > 0 do
			int -= .225
			local x4,y4,z4 = math.floor(x0+x3),math.floor(y0+y3),math.floor(z0+z3)
			local b,c = getBlock(x4,y4,z4,d)
			if b and (b ~= 0) then
				local blast = idinfo[b].blast or idinfo[b].hardness or 0
				int -= (blast + .3) * .3
				if int > 0 then
					if b ~= 46 then
						if drop then
							local prop = indexVector(c.propdata,x4%16,y4,z4%16)
							dropBlock(b,c,Vector3.new(x4,y4,z4),prop)
						elseif math.random() < (1/power) then
							local prop = indexVector(c.propdata,x4%16,y4,z4%16)
							dropBlock(b,c,Vector3.new(x4,y4,z4),prop)
						end
					end

					c:Set(x4%16,y4,z4%16,0,true)

					if b == 46 then 
						local iteme = createEntity(Vector3.new(x4 + .5,y4 + .5,z4 + .5),"tnt",d)
						if iteme then
							iteme.Motion = Vector3.new((math.random()-.5)*0.05,0.1,(math.random()-.5)*0.05)
							iteme.Fuse = math.random(10,30)
							iteme:Initialize()
						end
					end
				end
			end
			x3 += x2
			y3 += y2
			z3 += z2
			int -= .3
		end
	end
	for x=-7,8 do
		x-=0.5
		for y=-7,9 do
			y-=0.5
			for z=-7,8 do
				z-=0.5
				castRay(x,y,z)
			end
		end
	end
end

function requestDamage(uuid,...)
	dmgreq[uuid] = {...}
end




function dropBlock(b,c,pos,prop)
	local dimension = c.Dimension
	if b == 59 then
		local stage = 0
		if prop then
			if prop.age then
				stage = prop.age
			end
		end
		--c)
		--b)
		if stage < 7 then
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 295,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		else
			local seeds = 0
			for i=1,3 do
				if math.random() < (4/7) then
					seeds += 1
				end
			end
			-- Seeds
			if seeds > 0 then
				local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
				if iteme then
					iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
					iteme.Item = {
						Count = seeds,
						id = 295,
					}
					iteme.PickupDelay = 10
					iteme:Initialize()
				end
			end
			-- Wheat
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 296,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		end
	elseif b == 13 then
		if math.random() < 0.1 then
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 318,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		else
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 13,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		end
	elseif b == 64 or b == 489 then
		local half = prop and prop.half or "lower"
		if half == "lower" then
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 324,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		end
	elseif b == 71 then
		local half = prop and prop.half or "lower"
		if half == "lower" then
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = 330,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		end
	else
		local result = drop_silktouch[b] or drop_any[b] or b
		if type(result) == "table" then
			local results = {}
			for _,v in pairs(result) do
				if math.random() <= v[1] then
					table.insert(results,{v[2],math.random(1,v[3] or 1)})
				end
			end
			for _,v in pairs(results) do
				local id = v[1]
				local count = v[2]
				local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
				if iteme then
					iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
					iteme.Item = {
						Count = count,
						id = id,
					}
					iteme.PickupDelay = 10
					iteme:Initialize()
				end
			end
		elseif result ~= 0 then
			local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",dimension)
			if iteme then
				iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
				iteme.Item = {
					Count = 1,
					id = result,
				}
				iteme.PickupDelay = 10
				iteme:Initialize()
			end
		end
	end
end

--[Path finding]

function pathFind(start,finish,size,nowater,dimension)

	local start = Vector3.new(math.floor(start.X),math.floor(start.Y),math.floor(start.Z))
	local finish = Vector3.new(math.floor(finish.X),math.floor(finish.Y),math.floor(finish.Z))

	local function h(pos)
		local dx = math.abs(pos.X - finish.X)
		local dy = math.abs(pos.Y - finish.Y)
		local dz = math.abs(pos.Z - finish.Z)
		return 1 * (dx + dy + dz) + (math.sqrt(2) - 2 * 1) * math.min(dx,dz)
	end

	local function indexV3(t,v3)
		for i,v in pairs(t) do
			if v3 == i then
				return v
			end
		end
	end
	local function setV3(t,v3,val)
		for i,v in pairs(t) do
			if i == v3 then
				t[i] = val
				return
			end
		end
		t[v3] = val
	end

	local open = {start}

	local cameFrom = {}
	local jumpFrom = {}

	local gScore = {}
	gScore[start] = 0

	local fScore = {}
	fScore[start] = h(start)

	local function reconstructPath(cur)
		--		local highest = 1
		--		for _,v in pairs(fScore) do
		--			if v > highest then
		--				highest = v
		--			end
		--		end
		--		for i,v in pairs(fScore) do
		--			local w = Instance.new("Part")
		--			w.Anchored = true
		--			w.Size = Vector3.new(1,1,1)
		--			w.Position = Vector3.new(i.X,i.Y,i.Z)*b_size
		--			w.Color = Color3.fromHSV((1-v/highest)/6,1,1)
		--			w.Transparency = .8
		--			w.Material = Enum.Material.Neon
		--			w.Parent = workspace
		--			game.Debris:AddItem(w,5)
		--		end
		--		
		--		local w = Instance.new("Part")
		--		w.Anchored = true
		--		w.Size = Vector3.new(1.8,1.8,1.8)
		--		w.Position = Vector3.new(cur.X,cur.Y,cur.Z)*b_size
		--		w.Color = Color3.new(0,1,1)
		--		w.Transparency = 0
		--		w.Material = Enum.Material.Neon
		--		w.Parent = workspace
		--		game.Debris:AddItem(w,5)

		local totalpath = {
			{Pos = cur}
		}
		while cameFrom[cur] do
			cur = cameFrom[cur]
			if cur ~= start then
				local tab = {Pos = cur}
				table.insert(totalpath,1,tab)

				--				local w = Instance.new("Part")
				--				w.Anchored = true
				--				w.Size = Vector3.new(1.2,1.2,1.2)
				--				w.Position = Vector3.new(cur.X,cur.Y,cur.Z)*b_size
				--				w.Color = Color3.new(0,1,0)
				--				w.Transparency = 0
				--				w.Material = Enum.Material.Neon
				--				w.Parent = workspace
				--				game.Debris:AddItem(w,5)
			end
		end
		return totalpath
	end

	--	local w = Instance.new("Part")
	--	w.Anchored = true
	--	w.Size = Vector3.new(2.2,2.2,2.2)
	--	w.Position = Vector3.new(finish.X,finish.Y,finish.Z)*b_size
	--	w.Color = Color3.new(0,0,1)
	--	w.Transparency = 0
	--	w.Material = Enum.Material.Neon
	--	w.Parent = workspace
	--	game.Debris:AddItem(w,5)

	local chances = 200

	while (#open > 0) and (chances > 0) do
		local current = nil

		local lowest = math.huge
		for _,v in pairs(open) do
			if indexV3(fScore,v) < lowest then
				lowest = indexV3(fScore,v)
				current = v
			end
		end

		if current == finish then
			return reconstructPath(current)
		end

		table.remove(open,table.find(open,current))

		local function ay(node,jump)
			local tgs = indexV3(gScore,current) + 1--d(current,node)
			if tgs < (indexV3(gScore,node) or math.huge) then
				cameFrom[node] = current
				setV3(gScore,node, tgs)
				setV3(fScore,node, indexV3(gScore,node) + h(node))
				if not table.find(open,node) then
					table.insert(open,node)
				end
			end
		end

		local function ayy(npos,jump)
			local b = getBlock(npos.X,npos.Y,npos.Z,dimension)
			if b and not isSolid(b) then
				if size.Y >= 1 then
					local b = getBlock(npos.X,npos.Y + 1,npos.Z,dimension)
					if b and not isSolid(b) then
						ay(npos,jump)
						return true
					end
				else
					ay(npos,jump)
					return true
				end
			end
		end

		local npos = Vector3.new(current.X,current.Y - 1,current.Z)

		local ceil = getBlock(npos.X,current.Y + 1,npos.Z,dimension)
		local b0 = getBlock(npos.X,npos.Y,npos.Z,dimension)
		if b0 and not isSolid(b0) then
			local landOnWater = false
			for y=(npos.Y-1),0,-1 do
				local b0 = getBlock(npos.X,y,npos.Z,dimension)
				if not (b0 and not isSolid(b0)) then
					if b0 and fluidid[b0] then
						landOnWater = true
					end
					npos = Vector3.new(current.X,y + 1,current.Z)
					break
				elseif b0 and fluidid[b0] then
					landOnWater = true
					npos = Vector3.new(current.X,y + 1,current.Z)
					break
				end
			end
			--setV3(fScore,current,nil)
			--setV3(gScore,current,nil)
			--current = cameFrom[current] or current
			if (not nowater) or (not landOnWater) then
				ay(npos)
			end
		else
			local onWater = b0 and fluidid[b0]
			local ceil = ceil and (isSolid(ceil))
			local north = false
			local east = false
			local south = false
			local west = false
			if ayy(Vector3.new(current.X,current.Y,current.Z - 1)) then
				north = true
			elseif not ceil and not onWater then
				ayy(Vector3.new(current.X,current.Y + 1,current.Z - 1),true)
			end
			if ayy(Vector3.new(current.X + 1,current.Y,current.Z)) then
				east = true
			elseif not ceil and not onWater then
				ayy(Vector3.new(current.X + 1,current.Y + 1,current.Z),true)
			end
			if ayy(Vector3.new(current.X,current.Y,current.Z + 1)) then
				south = true
			elseif not ceil and not onWater then
				ayy(Vector3.new(current.X,current.Y + 1,current.Z + 1),true)
			end
			if ayy(Vector3.new(current.X - 1,current.Y,current.Z)) then
				west = true
			elseif not ceil and not onWater then
				ayy(Vector3.new(current.X - 1,current.Y + 1,current.Z),true)
			end

			if north and west then
				ayy(Vector3.new(current.X - 1,current.Y,current.Z - 1))
			end
			if north and east then
				ayy(Vector3.new(current.X + 1,current.Y,current.Z - 1))
			end
			if south and west then
				ayy(Vector3.new(current.X - 1,current.Y,current.Z + 1))
			end
			if south and east then
				ayy(Vector3.new(current.X + 1,current.Y,current.Z + 1))
			end
		end

		chances = chances - 1
	end

	local current = nil
	local lowest = math.huge
	for i,v in pairs(fScore) do
		if v < lowest then
			lowest = v
			current = i
		end
	end
	return reconstructPath(current)
end

--[Storage & Slot system]

function getSlot(st,id)
	for i,v in pairs(st) do
		if v.Slot == id then
			return v,i
		end
	end
end

function setSlot(st,id,val)
	local exist,i = getSlot(st,id)
	if exist then
		table.remove(st,i)
	end
	val.Slot = id
	table.insert(st,val)
	return val
end

function moveSlot(st,slotn,ast,aslotn,count)
	local self = getSlot(st,slotn) or setSlot(st,slotn,{Count = 0})

	local id = self.id
	local count = math.min(self.Count or 0,count)
	if id and (count > 0) then

		local function removeSelf()
			local sv,si = getSlot(st,self.Slot)
			if si then
				table.remove(st,si)
			end
		end

		local aslot = getSlot(ast,aslotn)

		if aslot then
			local aid = aslot.id
			local acount = aslot.Count

			if (acount == 0) or (not (aid and (aid ~= 0))) then
				local dup = deepcopy(self)
				dup.Count = count
				setSlot(ast,aslotn,dup)

				self.Count -= count

				if self.Count <= 0 then
					removeSelf()
				end

				return true,count
			elseif aid and (aid == id) then
				local maxcount = idinfo[aid].Stack or 64
				count = math.min(count,maxcount - acount)

				if count > 0 then
					self.Count -= count
					aslot.Count = acount + count

					if self.Count <= 0 then
						removeSelf()
					end

					return true,count
				else
					return false,0
				end
			else
				local keep = deepcopy(self)
				setSlot(st,self.Slot,deepcopy(aslot))
				setSlot(ast,aslotn,keep)

				return true,keep.Count
			end
		else
			local dup = deepcopy(self)
			dup.Count = count
			setSlot(ast,aslotn,dup)

			self.Count = self.Count - count

			if self.Count <= 0 then
				removeSelf()
			end

			return true,count
		end
	end
	return false,0
end

function addEvent(d,...)
	table.insert(pendingEvents[d or "overworld"],{...})
end

--[Chunk system]

---- Tickets
function addGenTicket(x,y,d)
	local dime = d or "overworld"
	genTickets[dime][x] = genTickets[dime][x] or {}
	genTickets[dime][x][y] = true
end
function removeGenTicket(x,y,d)
	local dime = d or "overworld"
	local v = genTickets[dime][x] and genTickets[dime][x][y]
	if v then genTickets[dime][x][y] = nil end
end

function addTicket(x,y,l,d,info)
	local inf = {
		xPos = x,
		zPos = y,
		Level = l
	}
	if info then
		for i,v in pairs(info) do
			inf[i] = v
		end
	end
	setmetatable(inf,ticket)
	table.insert(tickets[d or "overworld"],inf)
	return inf
end

function getTicket(x,y,d)
	local lowest = 44
	for _,v in pairs(tickets[d or "overworld"]) do
		local prop = v.Level - (v.Radius or 0) + math.max(math.abs(x - v.xPos),math.abs(y - v.zPos))
		lowest = math.min(prop,lowest)
	end
	return lowest
end

function ticket:Tick(d)
	if self.Expire then
		self.Expire = self.Expire - 1
		if self.Expire <= 0 then
			self:Destroy(d)
		end
	end
end

function ticket:Destroy(d)
	local dime = d or "overworld"
	table.remove(tickets[dime],table.find(tickets[dime],self))
end

---- Generation
-- Adjusted scaling factors for smoother terrain

local function temperatureNoise(x, z, height)
	local temperatureSeed = math.random(-math.huge, math.huge)
	local result = 0

	-- You can adjust scaling factors for x, z, and height as needed
	local tempX = x * 0.0125
	local tempZ = z * 0.0125
	local tempHeight = height * 0.0125

	-- Add noise values at different octaves
	for i = 0, 6 do
		local mul = 2^i
		result = result + (math.noise(tempX / mul, tempZ / mul, tempHeight / mul, temperatureSeed) * mul / 2)
	end
	-- Adjust the overall temperature scaling factor
	result = result * 3

	-- Ensure temperature values are within a reasonable range
	return result
end

local function smoothTemperature(x, z)
	local corners = (temperatureNoise(x - 1, z - 1) + temperatureNoise(x + 1, z - 1) + temperatureNoise(x - 1, z + 1) + temperatureNoise(x + 1, z + 1)) / 4
	local sides = (temperatureNoise(x - 1, z) + temperatureNoise(x + 1, z) + temperatureNoise(x, z - 1) + temperatureNoise(x, z + 1)) / 8
	local center = temperatureNoise(x, z) / 4
	return corners + sides + center
end


local function smooth(x, y, z)
	local corners = (cNoise(x - 1, z - 1) + cNoise(x + 1, z - 1) + cNoise(x - 1, z + 1) + cNoise(x + 1, z + 1)) / 4 -- try 4
	local sides = (cNoise(x - 1, z) + cNoise(x + 1, z) + cNoise(x, z - 1) + cNoise(x, z + 1)) / 8
	local center = cNoise(x, z) / 4
	return corners + sides + center
end
function oNoise(x, y, o)
	local n = 0
	for i = 0, o and (o - 1) or 7 do
		local mul = 2^i
		local x = x / mul
		local y = y and y / mul
		n = n + (math.noise(x, y, mapseed) * mul / 2) -- Reduce the height contribution
	end
	return n
end

function cNoise(x, y)
	return oNoise(x + oNoise(x, y), y)
end
function getHM(x, z)
	return terrain.GetHM(x,z,mapseed,waterLevel)
end

--[[ Adjust the parameters and add a new argument for the y coordinate in the smooth function
local function smooth(x, y, z)
	local corners = (cNoise(x - 1, z - 1) + cNoise(x + 1, z - 1) + cNoise(x - 1, z + 1) + cNoise(x + 1, z + 1)) / 4
	local sides = (cNoise(x - 1, z) + cNoise(x + 1, z) + cNoise(x, z - 1) + cNoise(x, z + 1)) / 8
	local center = cNoise(x, z) / 4
	return corners + sides + center
end

function oNoise(x, z, o)
	local n = 0
	for i = 0, o and (o - 1) or 7 do
		local mul = 2^i
		local newX = x / mul
		local newZ = z / mul
		n = n + (math.noise(newX, 0, newZ, mapseed) * mul / 2)  -- Exclude y coordinate
	end
	return n
end

function cNoise(x, z)
	return oNoise(x + oNoise(x, z), z)
end

function getHM(x, z)
	local result = 0
	local diff = false
	local hL = cNoise(x * 0.1, z * 0.1) / 8
	local hH = cNoise(x * 0.1, z * 0.1) / 6

	result = hH
	result = result / 2

	if result < 0 then
		result = result * 0.7
	end

	local smoothness = smooth(x, 0, z)
	result = result + smoothness

	result = result * 0.3

	if diff == false then
		return gen_flat and math.floor(waterLevel) or math.floor(result + waterLevel)
	else
		-- return gen_flat and math.floor(waterLevel) or math.floor(result+waterLevel)
	end
end]]

---- Chunks
function chunk.generateChunk(cx,cy,d)
	----"Generating chunk",cx,cy)

	local	chunkRan = Random.new(math.noise(cx*mapseed,cy*mapseed,math.noise(cx*mapseed,cy*mapseed,mapseed)*10)*1000)

	local newchunk = {}
	setmetatable(newchunk,chunk)
	local blockdata = {}
	newchunk.blockdata = blockdata
	newchunk.propdata = {}
	newchunk.entitydata = {}
	newchunk.tileentities = {}
	newchunk.xPos = cx
	newchunk.zPos = cy
	newchunk.Dimension = d or "overworld"

	newchunk.loaded = true

	newchunk.generating = true

	local dimension = d or "overworld"

	if dimension == "overworld" then

		local left = getChunk(cx-1,cy,dimension)
		local right = getChunk(cx+1,cy,dimension)
		local front = getChunk(cx,cy-1,dimension)
		local back = getChunk(cx,cy+1,dimension)

		-- Soiling

		debug.profilebegin("Soiling")

		local bedrockRan = Random.new(math.noise(cx*0.1,cy*0.1,math.noise(cx*5,cy*5)*10)*1000)

		for x=0,15 do
			for z=0,15 do
				local rx = cx*16+x
				local ry = cy*16+z

				local height = getHM(rx,ry)

				local dirtThickness = -4
				local dirtT = height
				local stoneT = dirtT + dirtThickness
				for y=0,heightlimit-1 do
					if y==0 then indexVector(blockdata,x,y,z,7) -- Bedrock layer
					elseif (y<=4) and (bedrockRan:NextNumber() > (y*0.2)) then indexVector(blockdata,x,y,z,7) -- Bedrock layer
					elseif y<=stoneT then indexVector(blockdata,x,y,z,1) -- Stone transition
					elseif y<=dirtT then 

						indexVector(blockdata,x,y,z,3) -- Dirt transition

					else

						indexVector(blockdata,x,y,z,0) -- Air
					end
				end
			end
		end

		debug.profileend()

		-- Carving (Modified)

		debug.profilebegin("Carving")

		local caveRan = chunkRan
		for i=1,caveRan:NextInteger(0,2) do
			local pos = Vector3.new(caveRan:NextInteger(0,15),caveRan:NextInteger(0,8 + waterLevel-1),caveRan:NextInteger(0,15))
			local length = 45 + caveRan:NextNumber() * caveRan:NextNumber() * 120

			local th = caveRan:NextNumber() * math.pi * 2
			local Dth = 0
			local ph = caveRan:NextNumber() * math.pi * 2
			local Dph = 0

			local rad = caveRan:NextNumber() * caveRan:NextNumber()

			for i=1,length do
				pos = pos + Vector3.new(math.sin(th), math.sin(ph), math.cos(th))*0.7

				th = th + Dth * 2.4
				Dth = (Dth * 0.2) + (caveRan:NextNumber() - caveRan:NextNumber())^3
				ph = ph*0.9 + Dph*2
				Dph = (Dph * .2) + (caveRan:NextNumber() - caveRan:NextNumber())^3


				if caveRan:NextNumber() >= 0.05 then
					local function rep(n) return n + (caveRan:NextInteger(1,4) - 2) * 0.2 end
					local center = Vector3.new(rep(pos.X),rep(pos.Y),rep(pos.Z))

					local rad2 = ((heightlimit-1) - center.Y) / (heightlimit-1)
					rad2 = 1.6 + (rad2 * 0.3 + 0.2) * rad
					rad2 = rad2 * (0.4 + math.sin(i * math.pi / length) * 0.3)

					for x=math.floor(center.X - rad2),math.ceil(center.X + rad2) do
						for y=math.floor(center.Y - rad2),math.ceil(center.Y + rad2) do
							for z=math.floor(center.Z - rad2),math.ceil(center.Z + rad2) do
								local d = Vector3.new(x,y,z) - center
								if (d.X^2 * d.Y^2 + d.Z^2) < (rad2^2) then
									local x = math.floor(x)
									local y = math.floor(y)
									local z = math.floor(z)
									local b = indexVector(blockdata,x,y,z)
									if b and not nocaveid[b] then
										indexVector(blockdata,x,y,z,(y <= 10) and 11 or 0)
									elseif not b then
										local b1,c = getBlock(cx*16+x,y,cy*16+z,dimension)
										local b2 = b1
										if c and c.generating and b2 and not nocaveid[b2] then
											c:Set(x%16,y,z%16,(y <= 10) and 11 or 0)
										elseif not c then
											caves.overworld[cx] = caves.overworld[cx] or {}
											caves.overworld[cx][cy] = caves.overworld[cx][cy] or {}
											table.insert(caves.overworld[cx][cy],Vector3.new(x%16,y,z%16))
										end
									end
								end
							end
						end
					end
				end
			end
		end

		---- Check cave metadata

		debug.profilebegin("Metadata")

		local md = caves.overworld[cx] and caves.overworld[cx][cy]
		if md then
			for _,v in pairs(md) do
				local b = indexVector(blockdata,v.X,v.Y,v.Z)
				if b and not nocaveid[b] then
					indexVector(blockdata,v.X,v.Y,v.Z,(v.Y <= 10) and 11 or 0)
				end
			end
			caves.overworld[cx][cy] = nil
		end

		debug.profileend()
		debug.profileend()

		-- Ore veins

		debug.profilebegin("Ore veins")

		local oreRan = chunkRan--:Clone()
		local function genOre(id,s,max,min)
			local pos = Vector3.new(oreRan:NextInteger(0,15),oreRan:NextInteger(min,max),oreRan:NextInteger(0,15))
			local length = s * 1

			local th = caveRan:NextNumber() * math.pi * 2
			local Dth = 0
			local ph = caveRan:NextNumber() * math.pi * 2
			local Dph = 0

			for i=1,length do
				pos = pos + Vector3.new(math.sin(th)*math.cos(ph), math.cos(th)*math.cos(ph), math.sin(ph))

				th = th + Dth * 0.2
				Dth = (Dth * 0.9) + caveRan:NextNumber() - caveRan:NextNumber()
				ph = ph/2 + Dph/4
				Dph = (Dph * .9) + caveRan:NextNumber() - caveRan:NextNumber()

				local rad = s

				for x=math.floor(pos.X - rad),math.ceil(pos.X + rad) do
					for y=math.floor(pos.Y - rad),math.ceil(pos.Y + rad) do
						for z=math.floor(pos.Z - rad),math.ceil(pos.Z + rad) do
							local d = Vector3.new(x,y,z) - pos
							if (d.X^2 + d.Y^2 + d.Z^2) < (rad^2) then
								local x = math.floor(x)
								local y = math.floor(y)
								local z = math.floor(z)
								local b = indexVector(blockdata,x,y,z)
								if b and ((b == 1) or gen_air_ores) then
									indexVector(blockdata,x,y,z,id)
								elseif not b then
									local b1,c = getBlock(cx*16+x,y,cy*16+z,dimension)
									local b2 = b1
									if c and c.generating and b2 and ((b2 == 1) or gen_air_ores) then
										c:Set(x%16,y,z%16,id)
									elseif not c then
										ores.overworld[cx] = ores.overworld[cx] or {}
										ores.overworld[cx][cy] = ores.overworld[cx][cy] or {}
										table.insert(ores.overworld[cx][cy],{Vector3.new(x%16,y,z%16),id})
									end
								end
							end
						end
					end
				end
			end
		end
		--local function genOre(ab,id,s,max)
		--	for i=1,256*heightlimit*ab/16384*64 do
		--		genSingleOre(id,s,max,1)
		--	end
		--end

		for i=1,20 do
			genOre(16,1.4,127,0) -- Coal
		end
		--[[for i=1,20 do
			genOre(119,1,110,0) -- Emerald
		end]]
		for i=1,20 do
			genOre(15,1,63,0) -- Iron
		end
		for i=1,2 do
			genOre(14,1,31,0) -- Gold
		end
		genOre(56,1.1,15,1) -- Diamond


		debug.profilebegin("Metadata")

		---- Check ore metadata

		local md = ores.overworld[cx] and ores.overworld[cx][cy]
		if md then
			for _,v in pairs(md) do
				local b = indexVector(blockdata,v[1].X,v[1].Y,v[1].Z)
				if b and ((b == 1) or gen_air_ores) then
					indexVector(blockdata,v[1].X,v[1].Y,v[1].Z,v[2])
				end
			end
			ores.overworld[cx][cy] = nil
		end

		debug.profileend()
		debug.profileend()


		-- Watering

		debug.profilebegin("Watering")

		local open = {}

		if left and left.blockdata then
			for y=0,heightlimit-1 do
				for z=0,15 do
					local b = indexVector(left.blockdata,15,y,z)
					if b and (b == 9) then
						indexVector(blockdata,0,y,z,9)
						table.insert(open,Vector3.new(0,y,z))
					end
				end
			end
		else
			addGenTicket(cx-1,cy,"overworld")
		end
		if right and right.blockdata then
			for y=0,heightlimit-1 do
				for z=0,15 do
					local b = indexVector(right.blockdata,0,y,z)
					if b and (b == 9) then
						indexVector(blockdata,15,y,z,9)
						table.insert(open,Vector3.new(15,y,z))
					end
				end
			end
		else
			addGenTicket(cx+1,cy,"overworld")
		end
		if front and front.blockdata then
			for y=0,heightlimit-1 do
				for x=0,15 do
					local b = indexVector(front.blockdata,x,y,15)
					if b and (b == 9) then
						indexVector(blockdata,x,y,0,9)
						table.insert(open,Vector3.new(x,y,0))
					end
				end
			end
		else
			addGenTicket(cx,cy-1,"overworld")
		end
		if back and back.blockdata then
			for y=0,heightlimit-1 do
				for x=0,15 do
					local b = indexVector(back.blockdata,x,y,0)
					if b and (b == 9) then
						indexVector(blockdata,x,y,15,9)
						table.insert(open,Vector3.new(x,y,15))
					end
				end
			end
		else
			addGenTicket(cx,cy+1,"overworld")
		end

		for i=1,5 do
			local rx = math.random(0,15)
			local rz = math.random(0,15)

			local s = indexVector(blockdata,rx,waterLevel-1,rz)
			if s == 0 then
				indexVector(blockdata,rx,waterLevel-1,rz,9)
				table.insert(open,Vector3.new(rx,waterLevel-1,rz))
			end
		end

		local function iterateFill(x,y,z)
			local function rep2(x,y,z)
				local a = indexVector(blockdata,x,y,z)
				if a then
					if a == 0 then
						indexVector(blockdata,x,y,z,9)
						table.insert(open,Vector3.new(x,y,z))
					end
				else
					local a,c = getBlock(cx*16+x,y,cy*16+z,dimension)
					if a and (a == 0) then
						c:Set(x%16,y,z%16,9)
						table.insert(open,Vector3.new(x,y,z))
					end
				end
			end
			rep2(x,y-1,z)
			rep2(x-1,y,z)
			rep2(x,y,z-1)
			rep2(x+1,y,z)
			rep2(x,y,z+1)
		end

		debug.profilebegin("Filling")

		while #open > 0 do
			local v = table.remove(open,1)
			iterateFill(v.X,v.Y,v.Z)
		end


		debug.profileend()

		-- Melting

		-- Growing
		debug.profilebegin("Growing")

		for x=0,15 do
			for z=0,25 do
				local rx = cx*16+x
				local ry = cy*16+z

				local height = getHM(rx,ry)
				-- Add this function to determine biome based on coordinates
				local function determineBiome(rx, ry)
					local biomeSeed = rx * 1024 + ry * 512 -- You can adjust these constants

					if (biomeSeed % 3 == 0) then
						return "sand_biome"  -- Example: Every 3rd seed is a sand biome
					else
						return "other_biome"
					end
				end

				-- Inside your loop, replace the existing sandC condition with biome detection
				local biomeType = determineBiome(rx, ry)


				local blockO = indexVector(blockdata,x,height,z)
				local snowc = oNoise(rx,ry) > 7
				local sandC = oNoise(rx, ry) < 14
				local sandChance = oNoise(rx,ry) > 8
				local GrassBlock = oNoise(rx, ry) > 12  + math.random() * 5 -- doenst work
				local gravelC = oNoise(rx,ry) < 14
				local y = math.max(0,math.floor(height))
				local temperature = temperatureNoise(rx, ry, y)

				--print(temperature)

				if blockO == 0 then
					while (blockO == 0) and (height > 0) do
						height = height - 1
						blockO = indexVector(blockdata,x,height,z)
					end
				end
				local blockA = indexVector(blockdata,x,y+1,z) or 0
				if (y > 1) and (blockO ~= 0) then
					if (blockA == 9) and gravelC then
						indexVector(blockdata,x,y,z,12)
						indexVector(blockdata,x,y - 1,z,12)
						indexVector(blockdata,x,y - 2,z,12)
					elseif (blockA == 0) then
					end
				end
				--	indexVector(blockdata,x,y,z,346)
				

			if temperature <= 0 and y >= 46 and temperature > -15 then -- snow
					indexVector(blockdata,x,y,z,340)	
				elseif temperature <= 4 and y >= 46 and temperature > 0 then -- taiga
					indexVector(blockdata,x,y,z,346)
				elseif temperature > 10 and y >= 46 and temperature < 13 then-- grass
					indexVector(blockdata,x,y,z,2)
				--[[elseif temperature > 13 and y < 53 and y >= 46 and temperature < 15 then-- swamp
					indexVector(blockdata,x,y,z,358)]]
				elseif temperature >= 15 and y >= 46 then -- desert
					indexVector(blockdata,x,y,z,12)
					indexVector(blockdata,x,y - 1,z,12)
					indexVector(blockdata,x,y - 2,z,12)
					indexVector(blockdata,x,y - 3,z,339)
					indexVector(blockdata,x,y - 4,z,339)
					indexVector(blockdata,x,y - 5,z,339)
					local random = math.random(1,950)
					--	if y > waterLevel then
					if random < 20  and getBlock(x,y+1,z) ~= 9 and getBlock(x,y,z) ~= 9 and getBlock(x,y+1,z) ~= 8  and getBlock(x + 1,y,z) ~= 12 and  getBlock(x - 1,y,z) ~= 12  and  getBlock(x,y,z -1) ~= 12 and  getBlock(x,y,z + 1) ~= 12    then
						indexVector(blockdata,x,y + 1,z,123)
						local random1 = math.random(1,60)
						if random1 < 45  then
							indexVector(blockdata,x,y + 2,z,123)
						end
						local random2 = math.random(1,100)
						if random2 < 45 and random1 < 45  then
							indexVector(blockdata,x,y + 3,z,123) -- cactus generatiopn
						end
					end
					local random3 = math.random(1,50)
					if random3 > 29 and random3 < 30 then
						local block = getBlock(x,y+2,z)
						if block ~= 123 then
							indexVector(blockdata,x,y+ 1,z,357)
						end
					end
				else-- grass (default biome)
					if y >= 46 then
						indexVector(blockdata,x,y,z,2) 
					end
				end

				--sand on edge of island
				if sandChance  then
					if y == 46 or y == 47 or y == 45 or y == 44 then
						if temperature > 10 and temperature < 12 then
							indexVector(blockdata,x,y,z,12)
							indexVector(blockdata,x,y - 1,z,12)	
						end
					end
					elseif gravelC then
					if y == 46 or y == 47 or y == 45 or y == 44 then
						if temperature > 10 and temperature < 12 then
							indexVector(blockdata,x,y,z,13)
							indexVector(blockdata,x,y - 1,z,13)	
						end
					end
				end
					
				if temperature <= 0 and y == 46 and temperature > -15 then
					indexVector(blockdata,x,y,z,345)
				end
				
				--]]

				--[[if (y > 1) and (blockO ~= 0) then
					if (blockA == 9) and gravelC then
						indexVector(blockdata,x,y,z,13)
						indexVector(blockdata,x,y - 1,z,13)
					elseif (blockA == 0) then

						if (y <= 60) and sandC then
							indexVector(blockdata,x,y,z,12)
							indexVector(blockdata,x,y - 1,z,12)
							indexVector(blockdata,x,y - 2,z,12)
							indexVector(blockdata,x,y - 3,z,339)
							indexVector(blockdata,x,y - 4,z,339)
							indexVector(blockdata,x,y - 5,z,339)
							local random = math.random(1,950)
							--	if y > waterLevel then
							if random < 20  and getBlock(x,y+1,z) ~= 9 and getBlock(x,y,z) ~= 9 and getBlock(x,y+1,z) ~= 8  and getBlock(x + 1,y,z) ~= 12 and  getBlock(x - 1,y,z) ~= 12  and  getBlock(x,y,z -1) ~= 12 and  getBlock(x,y,z + 1) ~= 12    then
								indexVector(blockdata,x,y + 1,z,123)
								local random1 = math.random(1,60)
								if random1 < 45  then
									indexVector(blockdata,x,y + 2,z,123)
								end
								local random2 = math.random(1,100)
								if random2 < 45 and random1 < 45  then
									indexVector(blockdata,x,y + 3,z,123) -- cactus generatiopn
								end
							end
							elseif (y >= 65) and snowc and not sandC then
								indexVector(blockdata,x,y,z,340)
							--end
						elseif not sandC and y < 49 and sandChance then
							indexVector(blockdata,x,y,z,12)
							indexVector(blockdata,x,y - 1,z,12)

						else 
							indexVector(blockdata,x,y,z,2)
						end
						
					end
				end--]]
			end

			debug.profileend()

			-- Planting

			debug.profilebegin("Planting")
		end

		local grassRan = chunkRan
		--	
		local random = math.random(1,40)
		if random < 20 then
			for i=1,256*heightlimit/16000 do
				local pos1 = Vector2.new(chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15))
				for i2=1,3 do
					local pos2 = pos1
					for i3=1,3 do
						pos2 = Vector2.new(pos2.X + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6),pos2.Y + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6))

						if (pos2.X >= 0) and (pos2.X <= 15) and (pos2.Y >= 0) and (pos2.Y <= 15) then
							local x,y,z = pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y

							local up = indexVector(blockdata,x,y,z)
							local root = indexVector(blockdata,x,y - 1,z)
							--					
							if root and (root == 2) and not (up and (up ~= 0)) then
								indexVector(blockdata,x,y,z,31)
							elseif root and (root == 346) and not (up and (up ~= 0)) then
								local random = math.random(1,2)
								if random == 1 then
									indexVector(blockdata,x,y,z,351)
								else
									indexVector(blockdata,x,y,z,352)

								end
							elseif root and (root == 358) and not (up and (up ~= 0)) then
								indexVector(blockdata,x,y,z,359)
							end
						end
					end
				end
			end
			--	
		end
		local random2 = math.random(1,100)
		if random2 < 10 then
			for i=1,1 do
				local pos1 = Vector2.new(chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15))
				for i2=1,13 do
					local pos2 = pos1
					for i3=1,1 do
						pos2 = Vector2.new(pos2.X + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6),pos2.Y + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6))

						if (pos2.X >= 0) and (pos2.X <= 15) and (pos2.Y >= 0) and (pos2.Y <= 15) then
							local x,y,z = pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y

							local up = indexVector(blockdata,x,y,z)
							local root = indexVector(blockdata,x,y - 1,z)
							--					
							if root and (root == 2) and not (up and (up ~= 0)) then
								indexVector(blockdata,x,y,z,99)
								
							end
						end
					end
				end
			end
			--	
		end
		local random88 = math.random(1,100)
		if random88 < 8 then
			for i=1,1 do
				local pos1 = Vector2.new(chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15))
				for i2=1,13 do
					local pos2 = pos1
					for i3=1,1 do
						pos2 = Vector2.new(pos2.X + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6),pos2.Y + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6))

						if (pos2.X >= 0) and (pos2.X <= 15) and (pos2.Y >= 0) and (pos2.Y <= 15) then
							local x,y,z = pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y

							local up = indexVector(blockdata,x,y,z)
							local root = indexVector(blockdata,x,y - 1,z)
							--					
							if root and (root == 358) and not (up and (up ~= 0)) then
								indexVector(blockdata,x,y,z,39)

							end
						end
					end
				end
			end
			--	
		end
		local random3 = math.random(1,101)
		if random3 < 10 then
			for i=1,1 do
				local pos1 = Vector2.new(chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15))
				for i2=1,1 do
					local pos2 = pos1
					for i3=1,1 do
						pos2 = Vector2.new(pos2.X + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6),pos2.Y + grassRan:NextInteger(1,6) - grassRan:NextInteger(1,6))

						if (pos2.X >= 0) and (pos2.X <= 15) and (pos2.Y >= 0) and (pos2.Y <= 15) then
							local x,y,z = pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y

							local up = indexVector(blockdata,x,y,z)
							local root = indexVector(blockdata,x,y - 1,z)
							--					
							if root and (root == 2) and not (up and (up ~= 0)) then
								indexVector(blockdata,x,y,z,100)
							end
						end
					end
				end
			end
			--	
		end
		local treeRan = chunkRan

		local function isSpaceForTree(pos,treeh)
			-- Canopy layer
			-- treeh-1 (max)
			-- treeh-2 (max-1)
			-- treeh-3 (max-2)
			-- treeh-4 (max-3)

			for i=0,treeh-5 do
				for x=-1,1 do
					for y=-1,1 do
						local b = indexVector(blockdata,pos.X + x,pos.Y + i,pos.Z + y)
						if not (b and (b == 0)) then
							return false
						end
					end
				end
			end
			for i=treeh-4,treeh-1 do
				for x=-2,2 do
					for y=-2,2 do
						local b = indexVector(blockdata,pos.X + x,pos.Y + i,pos.Z + y)
						if not (b and (b == 0)) then
							return false
						end
					end
				end
			end

			return true
		end
		local function growTree(pos2,treeh)
			if pos2.Y < waterLevel + 1 then
				return
			end
			local birchrandom = math.random(1,100)

			local id = 17
			local leaves = 18
			local isbirch = false
			for i=0,treeh-5 do
				if birchrandom < 30 then
					indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,998)
					id = 998
					leaves = 356
					isbirch = true
				elseif isbirch == false then
					indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,17)
					id = 17
				end
			end
			for i2=0,1 do
				local i = i2 + treeh-4
				local pattern = {
					[-2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
					[-1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[0] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = id,
						[1] = leaves,
						[2] = leaves,
					},
					[1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-2
				local pattern = {
					[-1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
					[0] = {
						[-1] = leaves,
						[0] = id, -- so it doenst dissapear yk
						[1] = leaves,
					},
					[1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-1
				local pattern = {
					[-1] = {
						[-1] = 0,
						[0] = leaves,
						[1] = 0,
					},
					[0] = {
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
					},
					[1] = {
						[-1] = 0,
						[0] = leaves,
						[1] = 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end

		end
		
		local function growSwampTree(pos2,treeh)
			if pos2.Y < waterLevel + 1 then
				return
			end

			local id = 17
			local leaves = 360
			for i=0,treeh-5 do
					indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,17)
					id = 17
			end
			for i2=0,1 do
				local i = i2 + treeh-4
				local pattern = {
					[-2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
					[-1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[0] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = id,
						[1] = leaves,
						[2] = leaves,
					},
					[1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-2
				local pattern = {
					[-1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
					[0] = {
						[-1] = leaves,
						[0] = id, -- so it doenst dissapear yk
						[1] = leaves,
					},
					[1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and leaves or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-1
				local pattern = {
					[-1] = {
						[-1] = 0,
						[0] = leaves,
						[1] = 0,
					},
					[0] = {
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
					},
					[1] = {
						[-1] = 0,
						[0] = leaves,
						[1] = 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end

		end

		local function growSnowTree(pos2,treeh)
			if pos2.Y < waterLevel + 1 then
				return
			end

			local id = 17
			local leaves = 18
			for i=0,treeh-5 do
				indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,17)
				id = 17
			end
			for i2=0,1 do
				local i = i2 + treeh-4
				local pattern = {
					[-2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
					},
					[-1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[0] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = id,
						[1] = leaves,
						[2] = leaves,
					},
					[1] = {
						[-2] = leaves,
						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,
						[2] = leaves,
					},
					[2] = {
						[-2] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,

						[-1] = leaves,
						[0] = leaves,
						[1] = leaves,

						[2] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-2
				local pattern = {
					[-1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
					},
					[0] = {
						[-1] = leaves,
						[0] = id, -- so it doenst dissapear yk
						[1] = leaves,
					},
					[1] = {
						[-1] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
						[0] = leaves,
						[1] = (treeRan:NextInteger(0,1) == 1) and 18 or 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end
			do
				local i = treeh-1
				local pattern = {
					[-1] = {
						[-1] = 0,
						[0] = 18,
						[1] = 0,
					},
					[0] = {
						[-1] = 18,
						[0] = 18,
						[1] = 18,
					},
					[1] = {
						[-1] = 0,
						[0] = 18,
						[1] = 0,
					},
				}
				for x,t1 in pairs(pattern) do
					for y,id in pairs(t1) do
						indexVector(blockdata,pos2.X + x,pos2.Y + i,pos2.Z + y,id)
					end
				end
			end

		end

		local function goddamnspruce(pos2,treeh)
			if pos2.Y < waterLevel + 1 then
				return
			end

			local id = 348
			local leaves = 347
			for i = 0,4 do
				indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,17)
			end
			local baseplateSize = 1  -- You can adjust this value to change the size of the baseplate

			-- leaves
			local function createBlockCube(pos,height,bottom)
				local blockID = 347 -- You can change this to the desired block ID
				local cubeSize = 5

				local offsetX = math.floor(cubeSize / 2)
				local offsetY = math.floor(cubeSize / 2)
				local offsetZ = math.floor(cubeSize / 2)

				for i = -offsetX, offsetX do
					for j = -offsetY, offsetY do
						for k = -offsetZ, offsetZ do
							-- Exclude the corners
							if not ((i == -offsetX or i == offsetX) and
								(k == -offsetZ or k == offsetZ)) then
								indexVector(blockdata, pos.X + i, pos.Y + height, pos.Z + k, blockID)
							end
						end
					end
				end						
				for j = -offsetY + 1, offsetY - 1 do
					indexVector(blockdata, pos.X + 1, pos.Y + height + 1, pos.Z, blockID)
					indexVector(blockdata, pos.X - 1, pos.Y + height + 1, pos.Z, blockID)
					indexVector(blockdata, pos.X, pos.Y + height + 1, pos.Z + 1, blockID)
					indexVector(blockdata, pos.X, pos.Y + height + 1, pos.Z - 1, blockID)
				end
				if bottom then
					indexVector(blockdata, pos.X,pos.Y + 5, pos.Z, id)
					indexVector(blockdata, pos.X,pos.Y + 6, pos.Z, id)
					indexVector(blockdata, pos.X,pos.Y + 7, pos.Z, blockID) -- so it doenst look ugly lol
					local oldheight = height
					--[[
					height = -height
					for j = -offsetY + 1, offsetY - 1 do
						indexVector(blockdata, pos.X + 1, pos.Y + height + 1, pos.Z, blockID)
						indexVector(blockdata, pos.X - 1, pos.Y + height + 1, pos.Z, blockID)
						indexVector(blockdata, pos.X, pos.Y + height + 1, pos.Z + 1, blockID)
						indexVector(blockdata, pos.X, pos.Y + height + 1, pos.Z - 1, blockID)
					end
					--]]
					height = 6
					for j = -offsetY + 1, offsetY - 1 do
						indexVector(blockdata, pos.X + 1, pos.Y + height , pos.Z, blockID)
						indexVector(blockdata, pos.X - 1, pos.Y + height , pos.Z, blockID)
						indexVector(blockdata, pos.X, pos.Y + height , pos.Z + 1, blockID)
						indexVector(blockdata, pos.X, pos.Y + height, pos.Z - 1, blockID)
					end

				end
			end								




			createBlockCube(Vector3.new(pos2.X,pos2.Y,pos2.Z),1)
			createBlockCube(Vector3.new(pos2.X,pos2.Y,pos2.Z),3,true)
			for i = 0,4 do
				indexVector(blockdata,pos2.X,pos2.Y + i,pos2.Z,348)
			end -- make sure
		end			




		if not gen_notrees then
			for i=1,4 do
				local pos1 = Vector2.new(chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15))
				for i2=1,10 do
					local pos2 = pos1
					for i3=1,10 do
						pos2 = Vector2.new(pos2.X + treeRan:NextInteger(1,6) - treeRan:NextInteger(1,6),pos2.Y + treeRan:NextInteger(1,6) - treeRan:NextInteger(1,6))

						if (pos2.X >= 0) and (pos2.X <= 15) and (pos2.Y >= 0) and (pos2.Y <= 15) and (treeRan:NextNumber() <= .25) then
							local root = indexVector(blockdata,pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y),pos2.Y)

							if root and (root == 2) then
								local pos2 = Vector3.new(pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y)
								local treeh = treeRan:NextInteger(1,3) + 4

								if isSpaceForTree(pos2,treeh) then
									growTree(pos2,treeh)
								end
							elseif root and (root == 340) then
								local pos2 = Vector3.new(pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y)
								local treeh = treeRan:NextInteger(1,3) + 4

								if isSpaceForTree(pos2,treeh) then
									local random = math.random(1,3)
									if random == 3 then
										growSnowTree(pos2,treeh)
									end
								end
							elseif root and (root == 346 or root == 340) then
								local pos2 = Vector3.new(pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y)
								local treeh = treeRan:NextInteger(1,3) + 4

								if isSpaceForTree(pos2,treeh) then
									local random = math.random(1,3)
									goddamnspruce(pos2,7)
								end
							elseif root and (root == 358) then
								local pos2 = Vector3.new(pos2.X,getHM(cx*16+pos2.X,cy*16+pos2.Y) + 1,pos2.Y)
								local treeh = treeRan:NextInteger(1,3) + 4

								if isSpaceForTree(pos2,treeh) then
									local random = math.random(1,3)
									growSwampTree(pos2,treeh)
								end
							end
						end
					end
				end
			end
		end

		debug.profileend()

		-- Spawning

		for i=1,chunkRan:NextInteger(0,1) do
			local rX,rZ = chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15)
			for rY=heightlimit-1,1,-1 do
				if isSolid(indexVector(blockdata,rX,rY,rZ)) then
					attemptSpawn("pig",chunkRan:NextInteger(1,3),Vector3.new(cx*16 + rX,rY,cy*16 + rZ))
					break
				end
			end
		end
		for i=1,chunkRan:NextInteger(0,1) do
			local rX,rZ = chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15)
			for rY=heightlimit-1,1,-1 do
				if isSolid(indexVector(blockdata,rX,rY,rZ)) then
					attemptSpawn("sheep",chunkRan:NextInteger(1,3),Vector3.new(cx*16 + rX,rY,cy*16 + rZ))
					break
				end
			end
		end
		for i=1,chunkRan:NextInteger(0,1) do
			local rX,rZ = chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15)
			for rY=heightlimit-1,1,-1 do
				if isSolid(indexVector(blockdata,rX,rY,rZ)) then
					attemptSpawn("cow",chunkRan:NextInteger(1,3),Vector3.new(cx*16 + rX,rY,cy*16 + rZ))
					break
				end
			end
		end
		for i=1,chunkRan:NextInteger(0,1) do
			local rX,rZ = chunkRan:NextInteger(0,15),chunkRan:NextInteger(0,15)
			for rY=heightlimit-1,1,-1 do
				if isSolid(indexVector(blockdata,rX,rY,rZ)) then
					if math.random(1,40) == 2 then
					attemptSpawn("pigbaby",chunkRan:NextInteger(1,3),Vector3.new(cx*16 + rX,rY,cy*16 + rZ))
					break
					end
				end
			end
		end
	elseif dimension == "nether" then
		local function pigmenspawn(pos,type)
			if pos then
				attemptSpawn(type or "entity",1,pos,"nether")
			end
		end
		local bedrockRan = Random.new(math.noise(cx*0.1,cy*0.1,math.noise(cx*5,cy*5)*10)*1000)

		for x=0,15 do
			for z=0,15 do
				local rx = cx*16+x
				local rz = cy*16+z
				for y=0,heightlimit-1 do
					local ry = y

					local density = math.noise(rx/32,ry/32 + mapseed,rz/32) + (((ry - 64)/64) ^ 4) - .2 + ((math.noise(rx/128,rz/128,mapseed))^2) * .5

					if (y==0) or (y==127) then indexVector(blockdata,x,y,z,7) -- Bedrock layer
					elseif (y<=4) and (bedrockRan:NextNumber() > (y*0.2)) then indexVector(blockdata,x,y,z,7) -- Bedrock layer
					elseif 0<=density then
						indexVector(blockdata,x,y,z,87)

					elseif (y<=31) then indexVector(blockdata,x,y,z,11) -- Lava transition
					else
						indexVector(blockdata,x,y,z,0) -- Air
					end
				end
			end
		end

	end

	-- Final

	local dime = getfenv()[dimension]
	dime[cx] = dime[cx] or {}
	dime[cx][cy] = newchunk

	table.insert(loadedChunks[dimension],newchunk)
	removeGenTicket(cx,cy,dimension)

	return newchunk
end

function compressChunk(chunk) -- compresses the chunk
	local data = {}

	data.blockdata = {}
	data.tileentities = chunk.tileentities

	local it = 1
	local f = chunk.blockdata[0]
	local rid = f or 0
	local rp
	for i=1,256*heightlimit-1 do
		local b = chunk.blockdata[i]
		local p = chunk.propdata[i]
		if p then
			p = S_H:JSONEncode(p)
		end
		if ((not p) or (p == rp)) and ((b or 0) == rid) then
			it = it + 1
		else
			table.insert(data.blockdata,it)
			table.insert(data.blockdata,rid)
			table.insert(data.blockdata,rp and S_H:JSONDecode(rp) or 0)
			it = 1
			rid = b or 0
			rp = p
		end
	end

	return data
end

function chunk:Load(d)
	if not self.loaded then
		debug.profilebegin("Load")

		local cur = 0
		local ind = 0

		local blockdata = {}
		local propdata = {}

		local rawdata = self.compressed

		while (ind*3) < #rawdata.blockdata do
			local v1,v2,v3 = rawdata.blockdata[ind*3+1],rawdata.blockdata[ind*3+2],rawdata.blockdata[ind*3+3]
			ind = ind + 1

			if v3 and (v3 ~= 0) then
				for i=1,v1 do
					indexVector(blockdata,cur%16,math.floor(cur/256),math.floor(cur/16)%16,v2)
					indexVector(propdata,cur%16,math.floor(cur/256),math.floor(cur/16)%16,v3)
					cur = cur + 1
				end
			else
				for i=1,v1 do
					indexVector(blockdata,cur%16,math.floor(cur/256),math.floor(cur/16)%16,v2)
					cur = cur + 1
				end
			end
		end

		if cur < (256*heightlimit) then
			for i=cur,256*heightlimit-1 do -- Fill in the null data
				indexVector(blockdata,cur%16,math.floor(cur/256),math.floor(cur/16)%16,0)
				cur = cur + 1
			end
		end

		local dime = d or "overworld"
		if not table.find(loadedChunks[dime],self) then
			table.insert(loadedChunks[dime],self)
		end

		self.compressed = nil
		self.blockdata = blockdata
		self.propdata = propdata
		self.loaded = true

		debug.profileend()
	end
end

function chunk:Compress()
	debug.profilebegin("Compress")
	----"Compressing",self.xPos,self.zPos)

	if self.loaded then
		self.compressed = compressChunk(self)
		self.blockdata = nil -- Remove data
		self.loaded = false
		local i = table.find(loadedChunks[self.Dimension],self)
		if i then
			table.remove(loadedChunks[self.Dimension],i)
		end
	end

	debug.profileend()

	return self.compressed
end

function chunk:GetTileEntity(x,y,z)
	for _,v in pairs(self.tileentities) do
		if ((v.x%16) == x) and (v.y == y) and ((v.z%16) == z) then
			return v
		end
	end
end

function chunk:RemoveTileEntity(x,y,z)
	for i,v in pairs(self.tileentities) do
		if ((v.x%16) == x) and (v.y == y) and ((v.z%16) == z) then
			table.remove(self.tileentities,i)
			return true
		end
	end
end

function chunk:SetTileEntity(x,y,z,te)
	self:RemoveTileEntity(x,y,z)
	te.x = x + self.xPos*16
	te.y = y
	te.z = z + self.zPos*16
	table.insert(self.tileentities,te)
	return te
end

function chunk:Set(x,y,z,i,u,p)
	--local data = self.blockdata
	if u then
		local origin = Vector3.new(self.xPos*16+x,y,self.zPos*16+z)
		table.insert(blocksets[self.Dimension],{origin,i,p})
		table.insert(blockupdates[self.Dimension],origin)
		for _,v in pairs(Enum.NormalId:GetEnumItems()) do
			table.insert(blockupdates[self.Dimension],origin + Vector3.FromNormalId(v))
		end
	end
	if i == 54 then
		local te = self:GetTileEntity(x,y,z)
		if not te then
			local dat = {
				id = 54,
				Items = {}
			}
			table.insert(tileentsets[self.Dimension], {x + self.xPos*16,y,z + self.zPos*16,self:SetTileEntity(x,y,z,dat)} )
		end
	elseif i == 61 then
		local te = self:GetTileEntity(x,y,z)
		if not te then
			local dat = {
				id = 61,

				Items = {},
				BurnTime = 0,
				BurnTimeTotal = 1,
				CookTime = 0,
				CookTimeTotal = 200
			}
			table.insert(tileentsets[self.Dimension], {x + self.xPos*16,y,z + self.zPos*16,self:SetTileEntity(x,y,z,dat)} )
		end
	else
		-- Drop existing items
		local te = self:GetTileEntity(x,y,z)
		if te then
			if te.Items then
				local origin = Vector3.new(self.xPos*16+x + .5,y + .5,self.zPos*16+z + .5)
				for _,v in pairs(te.Items) do
					if v.id and (v.id ~= 0) and v.Count and (v.Count > 0) then
						local iteme = createEntity(origin,"item",self.Dimension)
						if iteme then
							iteme.Motion = CFrame.fromEulerAnglesYXZ(0.15,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.1)
							iteme.Item = deepcopy(v)
							iteme.PickupDelay = 5
							iteme:Initialize()
						end
					end
				end
			end
			if self:RemoveTileEntity(x,y,z) then 
				table.insert(tileentsets[self.Dimension],{x + self.xPos*16,y,z + self.zPos*16}) 
			end
		end
	end
	indexVectorReplace(self.propdata,x,y,z,p)
	return indexVector(self.blockdata,x,y,z,i)
end


--function chunk:Change(x,y,z,over)
--	if type(over) == "number" then
--		indexVector(self.blockdata,x,y,z,over)
--		return over
--	else
--		local block = getBlockInfo(self:Get(x,y,z))
--		for i,v in pairs(over) do
--			block[i] = v
--		end
--		indexVector(self.blockdata,x,y,z,block)
--		return block
--	end
--end

function getChunk(x,y,d)
	--overworld[x] = overworld[x] or {}
	--local ch = overworld[x][y]
	--if not ch then
	--	ch = generateChunk(x,y)
	--	overworld[x][y] = ch
	--end
	if (not d) or (d == "overworld") then
		local cchunk = overworld[x] and overworld[x][y]

		if cchunk then
			return cchunk
		end
	else
		local dime = getfenv()[d or "overworld"]

		local cchunk = dime[x] and dime[x][y]

		if cchunk then
			return cchunk
		end
	end
end

--[The Tick function]
game.ReplicatedStorage.Spawn.OnServerEvent:Connect(function(plr,t)
	spawn(function()
		for i = 1,5 do
			game.ReplicatedStorage.Update:FireClient(plr,"MouseInvisible")
			game.ReplicatedStorage.Update:FireClient(plr,"RenderInventory")
			wait()
		end
	end)
	if t == "STRTD" then
		return
	end
	if t == "Start" then
		return
	end
	if t == "Retry" then
		playerinfo[plr] = nil
		
		return
	end
if t == "Death" then
		local playerData
		local Data = {
			Inventory = entity.New(nil)
		}
		local success, error = pcall(function()
			playerData = playerDataStore:SetAsync(tostring(plr.UserId),game.HttpService:JSONDecode(Data))
		end)
		spawnPlayer(plr)
end
end)



game.ReplicatedStorage.KnockUpdate.Event:Connect(function(position1, self) -- self is the player
	if self then
		if playerinfo[self["Player"]] ~= nil then
			local plr = playerinfo[self["Player"]]
			if plr.Health ~= 0 then
				local b = Instance.new("Vector3Value", self["Player"].Character)
				b.Name = "Knockback"
				b.Value = position1
				game.Debris:AddItem(b, 0.3)
			end
		end
	end
end)

game.ReplicatedStorage.Damage.Event:Connect(function(plr)
	if playerinfo[plr] then
		if playerinfo[plr].Health > 0 then
			playerinfo[plr].Health -= 1
		end
	end
end)
game.ReplicatedStorage.test.Event:Connect(function(plr)
	local e = plr.Character:FindFirstChild("DamageCooldown")
	if not e then
		local b = Instance.new("BoolValue",plr.Character)
		b.Name = "DamageCooldown"
		game.Debris:AddItem(b,1)
		if playerinfo[plr] then
			if playerinfo[plr].Health > 0 then
				playerinfo[plr].Health -= 1
			end
		end
	end
end)

game.ReplicatedStorage.UpdatePlayer.OnServerEvent:Connect(function(plr,e,pos)
	if e == nil then
		return
	end
	if  e == "Inventorytest"  then

	end
	if e == "Initialized"  then
		plr.Character:WaitForChild("Initialized").Value = true
		plr.Character:WaitForChild("canStart").Value = true
	end
	if e == "Drowning"  then
		if playerinfo[plr] then
			playerinfo[plr].Health = playerinfo[plr].Health - 1
		end
	end
	if e == "Started"  then
		if playerinfo[plr] then
			plr.Character:WaitForChild("canStart").Value = true
		end
	end
	if e == "Splash" then
		local watersplash = game.ServerStorage["FOR LATER USE"].Misc.Water:Clone()
		watersplash.Parent = plr.Character:WaitForChild("HumanoidRootPart")
		watersplash.MaxDistance = 65
		watersplash.Volume = 0.3
		watersplash:Play()
		watersplash.Ended:Connect(function()
			wait()
			watersplash:Destroy()
		end)
	end
	if e == "FallDamage" then
		local e = Instance.new("BoolValue",plr.Character)
		e.Name = "HasFall"
	end
end)
game.Players.PlayerAdded:Connect(function(e)
	repeat wait()

	until e.Character ~= nil
	wait(1)
	if getServerType() == "ReservedServer" then
		e.PlayerGui.Menu.Enabled = true
		wait(.1)
		e.PlayerGui.Menu.Enabled = false
	end
end)
local updates = {}
local world = {}
function doTick()
	ticks += 1
	workspace.WorldInfo.Clock.Value += 1
	workspace.WorldInfo.Clock.Value %= 29000
	workspace.WorldInfo.TicksPassed.Value = ticks

	---- Initialization
	for i,v in pairs(game.Players:GetChildren()) do
		if v:IsA("Player") then -- preventing being above 100 like 101
			if v:FindFirstChild("Hunger") then
				local hunger = v:FindFirstChild("Hunger")
				if hunger.Value > 100 then
					hunger.Value = 100
				end
			end
		end
	end
	local sounds = {}

	 updates = {}
	local function upCh(c)
		updates[c] = updates[c] or {
			blockdata = {},
			tileentities = {},
			entitydata = {},
			events = {}
		}
		return updates[c]
	end

	 world = {
		getChunk = getChunk,
		getBlock = getBlock,
		getBlockForCC = getBlockForCC,
		getPropData = getPropData,
		setBlock = setBlock,
		getNearbyEntities = getNearbyEntities,
		pathFind = pathFind,

		addEvent = addEvent,
		getSlot = getSlot,
		setSlot = setSlot,

		createEntity = createEntity,
		createExplosion = createExplosion
	}

	---- Tickets

	debug.profilebegin("Tickets")

	for d,e in pairs(tickets) do
		for _,v in pairs(e) do
			----"Ticked ticket",v)
			v:Tick(d)
		end
	end

	debug.profileend()

	---- Initialize player data

	local newplayers = {}

	for _,v in pairs(game.Players:GetPlayers()) do


		local char = v.Character
		if char then
			local human = char:FindFirstChildOfClass("Humanoid")
			local htorso = char:FindFirstChild("HumanoidRootPart")
			if human then
				human.PlatformStand = true
				human.BreakJointsOnDeath = false

			end
			if htorso then
				spawn(function()
					wait(1.5)
					htorso.Anchored = true
				end)
			end
		end

		-- Update player info

		if not playerinfo[v] then

			-- Find player entity with same user id
			newplayers[v] = true
			
		else
			playerinfo[v].updateInventory = false
			playerinfo[v].changeMotion = false
			if playerinfo[v].Health == 0 then
				--playerinfo[v].Pos = playerinfo[v].Pos
			end
			--v.PlayerGui.MainGui.HUD.DataFrame.VID.Text = "Biome: "..biome
		end
		if v and v.Character then
		if v.Character:FindFirstChild("RequestSpawn") and v:FindFirstChild("pressedbutton")  then
			if not playerinfo[v] then
				spawnPlayer(v)
			else
				
			end
		end
		else
		end
		local inf = playerinfo[v]
		if inf then
			if inf.AddMotion then
				inf.AddMotion = nil
			end
			if inf.Pos then
				local x,y,z = inf.Pos.X,inf.Pos.Y,inf.Pos.Z 

				local cx1,cy1 = math.floor(x/16),math.floor(z/16)
				addTicket(cx1,cy1,31,inf.Dimension,{Expire = 1,Radius = viewdistance})
			end
		end
	end

	---- Receive input

	debug.profilebegin("Receive input")

	local function breakBlock(plr,inf,b,c,pos,harvest)
		local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
		c:Set(pos.X%16,pos.Y,pos.Z%16,0,true)
		table.insert(upCh(c).events,{"sound",Vector3.new(pos.X + .5,pos.Y,pos.Z + .5),soundinfo.block[idinfo[b].sound]["break"],plr})

		if harvest and (inf.gamemode ~= 1) then	
			if b == 119 or b == 56 or b == 15 or b == 16 and workspace.WorldDebug.XP.Value == true then -- put you ore here to drop xp
			--	game.ReplicatedStorage.SpawnEntityRQ:Fire(Vector3.new(pos.X + .5,pos.Y - 1.5,pos.Z + .5),"xp",playerinfo[plr])
			end
			if b == 345 then
				setBlock(pos.X,pos.Y,pos.Z,9)
			end
			if b ~= 345 then
				dropBlock(b,c,pos,prop)
			end
		end
	end

	local function dropSlot(plr,inf,slotid,count)
		count = count or 64
		local slot,inum = getSlot(inf.Inventory,slotid)
		if slot and slot.Count then
			count = math.min(count,slot.Count)
			local id = slot.id
			local count2 = slot.Count or 0
			if id and (count2 > 0) then
				local pos = Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z)
				local cx,cy = math.floor(pos.X/16),math.floor(pos.Z/16)
				local c = getChunk(cx,cy,inf.Dimension)

				if c and c.loaded then
					local dropping = math.min(count,idinfo[id] and idinfo[id].Stack or 64)

					local iteme = createEntity(Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z),"item",inf.Dimension)
					if iteme then
						iteme.Motion = CFrame.fromEulerAnglesYXZ(inf.Rotation.Y,inf.Rotation.X,0).LookVector*0.5
						iteme.Item = {
							Count = dropping,
							id = id,
							tag = slot.tag
						}
						iteme.PickupDelay = 40
						iteme:Initialize()
					end

					slot.Count -= dropping
					if slot.Count <= 0 then
						table.remove(inf.Inventory,inum)
					end

					inf.updateInventory = true
				end
			end
		end
	end

	local function craftResult(plr,inf,openblock)
		local inventory = inf.Inventory

		local tab = {}

		local blockid = openblock and getBlock(openblock.X,openblock.Y,openblock.Z,inf.Dimension)

		if blockid and (blockid == 58) then

			local slot80 = getSlotContent(getSlot(inventory,80))
			local slot81 = getSlotContent(getSlot(inventory,81))
			local slot82 = getSlotContent(getSlot(inventory,82))
			local slot83 = getSlotContent(getSlot(inventory,83))
			local slot84 = getSlotContent(getSlot(inventory,84))
			local slot85 = getSlotContent(getSlot(inventory,85))
			local slot86 = getSlotContent(getSlot(inventory,86))
			local slot87 = getSlotContent(getSlot(inventory,87))
			local slot88 = getSlotContent(getSlot(inventory,88))

			for i=1,2 do
				if not (slot80[2] or slot83[2] or slot86[2]) then
					slot80 = slot81
					slot81 = slot82
					slot82 = {0}

					slot83 = slot84
					slot84 = slot85
					slot85 = {0}

					slot86 = slot87
					slot87 = slot88
					slot88 = {0}
				else
					break
				end
			end

			for i=1,2 do
				if not (slot80[2] or slot81[2] or slot82[2]) then
					slot80 = slot83
					slot83 = slot86
					slot86 = {0}

					slot81 = slot84
					slot84 = slot87
					slot87 = {0}

					slot82 = slot85
					slot85 = slot88
					slot88 = {0}
				else
					break
				end
			end

			tab = {
				slot80,slot81,slot82,
				slot83,slot84,slot85,
				slot86,slot87,slot88
			}

		else

			local slot80 = getSlotContent(getSlot(inventory,80))
			local slot81 = getSlotContent(getSlot(inventory,81))
			local slot82 = getSlotContent(getSlot(inventory,82))
			local slot83 = getSlotContent(getSlot(inventory,83))

			if not (slot80[2] or slot82[2]) then
				slot80 = slot81
				slot82 = slot83
				slot81 = {0}
				slot83 = {0}
			end

			if not (slot80[2] or slot81[2]) then
				slot80 = slot82
				slot81 = slot83
				slot82 = {0}
				slot83 = {0}
			end

			tab = {
				slot80,slot81,{0},
				slot82,slot83,{0},
				{0},{0},{0}
			}
		end

		local result = {0,0}
		for v,i in pairs(recipes[1]) do
			local correct = true
			for a=1,9 do
				local actual = tab[a]
				if not actual[2] then
					actual[2] = nil -- Lua as always.
				end
				if actual[2] ~= v[a] then
					correct = false
				end
			end
			if correct then
				result = {i,v[10] or 1}
				break
			end
		end

		local function consume(i)
			local slot = getSlot(inventory,i)
			local count = slot and slot.Count
			local id = slot and slot.id
			if slot and count and (count > 0) and id and (id ~= 0) then
				slot.Count -= 1
			end
		end

		if result[1] ~= 0 then
			local handslot = getSlot(inventory,-1)
			local hsc = getSlotContent(handslot)
			if not hsc[2] then
				for i=80,88 do consume(i) end
				setSlot(inventory,-1,{
					id = result[1],
					Count = result[2]
				})
			elseif hsc[2] == result[1] then
				if hsc[1] + result[2] <= (idinfo[result[1]].Stack or 64) then
					for i=80,88 do consume(i) end
					handslot.Count = hsc[1]+result[2]
				end
			end
		end

		--inf.updateInventory = true

	end

	for i,v in pairs(statequery) do
		if (i.Parent == game.Players) and playerinfo[i] then
			if v.query[1] then
				local state = table.remove(v.query,1)

				local ok,msg = pcall(function()

					local inf = playerinfo[i]
					local alive = inf.Health and (inf.Health > 0)

					inf.SelectedItemSlot = math.clamp(state.slotselect or inf.SelectedItemSlot or 0,0,8)

					local selslot,selnum = getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
					local selid = selslot and selslot.id
					local selcount = selslot and selslot.Count or 0

					-- Actions
					if state.icraft then
						craftResult(i,inf,state.openblock)
					end

					if state.imove then
						for _,m in ipairs(state.imove) do
							local transfer = m[1]
							local slot1,slot2 = m[2],m[3]
							local islot = getSlot(inf.Inventory,slot1)
							local count = m[4]

							local st
							local ast
							local ch,te,teid,dir
							local allowed = true
							if transfer == 0 then
								st = inf.Inventory
								ast = inf.Inventory
							else
								local iext
								local ext = state.itransfer
								ch = getChunk(math.floor(ext.X/16),math.floor(ext.Z/16),inf.Dimension)
								if ch and ch.loaded then
									te = ch:GetTileEntity(ext.X%16,ext.Y,ext.Z%16)
									if te then
										iext = te.Items
										teid = te.id
									end
								end
								if iext then
									if transfer == 1 then
										st = inf.Inventory
										ast = iext
										dir = 2
									elseif transfer == 2 then
										st = iext
										ast = inf.Inventory
										dir = 1
									elseif transfer == 3 then
										st = iext
										ast = iext
										dir = 3
									end
								else
									st = inf.Inventory
									ast = inf.Inventory
								end
							end
							if teid and (dir > 0) then
								-- External Inventory; Blocks
								if teid == 54 then -- Chest
									if (dir == 1) or (dir == 3) then
										if (slot1 >= 27) or (slot1 < 0) then
											allowed = false
										end
									end
									if (dir == 2) or (dir == 3) then
										if (slot2 >= 27) or (slot2 < 0) then
											allowed = false
										end
									end
								elseif teid == 61 then -- Furnace
									if dir == 3 then
										allowed = false -- No.
									else
										if (dir == 2) then -- Supply
											if slot2 == 2 then
												allowed = false
											elseif slot2 == 1 then
												if islot and not smeltrecipes[2][islot.id] then -- Not a fuel
													allowed = false
												end
											elseif slot2 == 0 then
												allowed = true
											else
												allowed = false
											end
										end
									end
								end
							else
								-- Internal Inventory
								if slot2 == -1 then
									allowed = true
								elseif (slot2 >= 100) and (slot2 <= 103) then -- Armor Slots
									allowed = false

									local armor
									local atype

									if islot and islot.id then
										local info = idinfo[islot.id]
										armor = info.armor
										atype = info.type
									end

									if slot2 == 103 then -- Helmet
										if armor and (atype == "helmet") then
											allowed = true
										end
									elseif slot2 == 102 then -- Chestplate
										if armor and (atype == "chestplate") then
											allowed = true
										end
									elseif slot2 == 101 then -- Leggings
										if armor and (atype == "leggings") then
											allowed = true
										end
									elseif slot2 == 100 then -- Boots
										if armor and (atype == "boots") then
											allowed = true
										end
									end
								elseif not ( ((slot2 >= 0) and (slot2 <= 35)) or ((slot2 >= 80) and (slot2 <= 88)) ) then -- Other
									allowed = false
								end
							end
							if allowed then
								moveSlot(st, slot1, ast, slot2, count)
								if ch and te then
									table.insert(tileentsets[inf.Dimension],{te.x,te.y,te.z,te})
								end
							end
						end
						--inf.updateInventory = true
					end

					if state.idrop then
						for _,d in pairs(state.idrop) do
							dropSlot(i,inf,d[1],d[2])
						end
					end

					if alive and state.iattack then

						local dmg = 1
						local tdmg

						if selid and (selcount > 0) then
							local inf = idinfo[selid] 

							local dmgtypes = {
								sword = {
									wood = 5,
									gold = 5,
									stone = 6,
									iron = 7,
									diamond = 8
								},
								axe = {
									wood = 4,
									gold = 4,
									stone = 5,
									iron = 6,
									diamond = 7
								},
								shovel = {
									wood = 2,
									gold = 2,
									stone = 3,
									iron = 4,
									diamond = 5
								},
								pickaxe = {
									wood = 3,
									gold = 3,
									stone = 4,
									iron = 5,
									diamond = 6,
								}
							}

							dmg = dmgtypes[inf.type] and dmgtypes[inf.type][inf.material] or 1

							if inf.type == "sword" then
								tdmg = 1
							elseif (inf.type == "pickaxe") or (inf.type == "shovel") or (inf.type == "axe") then
								tdmg = 2
							end
						end

						local id = state.targetEntity
						local plr = id and game.Players:FindFirstChild(id)
						if plr then
							local inf2 = playerinfo[plr]
							if inf2 and (inf2.Dimension == inf.Dimension)  and ((inf2.Pos - inf.Pos).Magnitude < 8) and workspace.WorldDebug.DisablePVP.Value == false then
								inf2:Damage(world,"generic",dmg,playerinfo[i])
								if inf2.Health == 0 and not plr.Character:FindFirstChild("Dead") then
									Instance.new("BoolValue",plr.Character).Name = "Dead"
									local data = {
										Message = tostring(inf2.Player.Name.." was slain by "..inf.Player.Name),
										Name = "Server",
										Color = Color3.fromRGB(252, 216, 10),
										MessageColor = Color3.fromRGB(252, 216, 10)
									}

									game.ReplicatedStorage.ServerMessage:FireAllClients(i,data,true)
								end
								if tdmg then
									if not selslot.tag then
										selslot.tag = {}
									end
									selslot.tag.Damage = (selslot.tag.Damage or 0) + tdmg
									if selslot.tag.Damage >= idinfo[selid].durability then
										selslot.tag.Damage = 0
										selslot.Count -= 1
										if selslot.Count <= 0 then
											local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
											if c and c.loaded then
												table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
											end
											table.remove(inf.Inventory,selnum)
											inf.updateInventory = true
										end
									end
								end
							end
						elseif id then
							for _,v in pairs(getNearbyEntities(playerinfo[i].Pos,inf.Dimension)) do
								if v.UUID == id then
									if ((v.Pos - inf.Pos).Magnitude < 8) then
										v:Damage(world,"generic",dmg,playerinfo[i])

										if tdmg then
											if not selslot.tag then
												selslot.tag = {}
											end
											selslot.tag.Damage = (selslot.tag.Damage or 0) + tdmg
											if selslot.tag.Damage >= idinfo[selid].durability then
												selslot.tag.Damage = 0
												selslot.Count -= 1
												if selslot.Count <= 0 then
													local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
													if c and c.loaded then
														table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
													end
													table.remove(inf.Inventory,selnum)
													inf.updateInventory = true
												end
											end
										end
									end
									break
								end
							end
						end

					elseif state.iplace then

						local pos1 = state.targetBlock
						local nor = state.targetBlockNor
						local pos2 = pos1 + nor
						local b1,c1 = getBlock(pos1.X,pos1.Y,pos1.Z,inf.Dimension)
						local b2,c2 = getBlock(pos2.X,pos2.Y,pos2.Z,inf.Dimension)

						local dist = (pos2 - inf.Pos).Magnitude

						local allowed = true
						local prop

						local aid = selid
						game.ReplicatedStorage.Update:FireClient(i,"RenderInventory")
						if b2 and (b2 ~= 0) and not fluidid[b2] then
							allowed = false
						elseif selid == 6 then
							allowed = false
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if g and ((g == 2) or (g == 3)) then
								allowed = true
							end
						elseif selid == 50 then -- Torch
							allowed = false
							if b1 and isSolid(b1) then
								if nor == Vector3.new(0,1,0) then
									allowed = true
								elseif nor == Vector3.new(1,0,0) then
									allowed = true
									prop = {facing = "east"}
								elseif nor == Vector3.new(-1,0,0) then
									allowed = true
									prop = {facing = "west"}
								elseif nor == Vector3.new(0,0,-1) then
									allowed = true
									prop = {facing = "north"}
								elseif nor == Vector3.new(0,0,1) then
									allowed = true
									prop = {facing = "south"}
								end
							end
						elseif (selid == 53) or (selid == 67) then -- Stairs
							local rot = inf.Rotation.X
							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north
								prop = {facing = "north"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west
								prop = {facing = "west"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south
								prop = {facing = "south"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east
								prop = {facing = "east"}
							end
						elseif (selid == 61) or (selid == 54) or (selid == 175)  then -- Rotating blocks (No up & down facing)
							local rot = inf.Rotation.X

							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
								prop = {facing = "south"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
								prop = {facing = "east"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
								prop = {facing = "north"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
								prop = {facing = "west"}
							end

							--]]
						elseif (selid == 69696)  then -- bed
							local rot = inf.Rotation.X

							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
								prop = {facing = "south"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
								prop = {facing = "east"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
								prop = {facing = "north"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
								prop = {facing = "west"}
							end
							--
							if prop.facing then
								local facingDirection = prop.facing

								local newPos = {X = pos2.X, Y = pos2.Y, Z = pos2.Z}
								local bed2tested = false
								if bed2tested then
									if facingDirection == "south" then
										newPos.Z = newPos.Z - 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.Z = newPos.Z + 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "east" then
										newPos.X = newPos.X - 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.X = newPos.X + 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "north" then
										newPos.Z = newPos.Z + 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.Z = newPos.Z - 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "west" then
										newPos.X = newPos.X + 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.X = newPos.X - 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									end
								end



								allowed = true


							end
							--]]

						elseif (selid == 259) then -- Flint and Steel
							aid = 51

							prop = {age = 0}

							local t = b1
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if t and (t == 46) then
								allowed = true
							elseif t and (t ~= 0) and idinfo[t].fire then
								allowed = true
							elseif g and (g ~= 0) and (g ~= 51) then
								allowed = true
							end
						elseif (selid == 295) then -- Wheat Seeds
							aid = 59
							allowed = false
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if g and (g == 60) then
								allowed = true
							end
						elseif (selid == 324) or (selid == 330) or (selid == 489)  then
							allowed = false

							if selid == 324 then
								aid = 64
							elseif selid == 330 then
								aid = 71
							elseif selid == 489 then
								aid = 489
							end

							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							local t = getBlock(pos2.X,pos2.Y+1,pos2.Z,inf.Dimension)
							if g and isSolid(g) and not (t and (t ~= 0)) then
								allowed = true

								local dir = 2

								local rot = inf.Rotation.X
								if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
									dir = 0
									prop = {facing = "south"}
								elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
									dir = 1
									prop = {facing = "east"}
								elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
									prop = {facing = "north"}
								elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
									dir = 3
									prop = {facing = "west"}
								end

								prop.half = "lower"

								local hinge = "left"
								if dir == 0 then
									local n = getBlock(pos2.X-1,pos2.Y,pos2.Z,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 1 then
									local n = getBlock(pos2.X,pos2.Y,pos2.Z+1,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 2 then
									local n = getBlock(pos2.X+1,pos2.Y,pos2.Z,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 3 then
									local n = getBlock(pos2.X,pos2.Y,pos2.Z-1,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								end

								prop.hinge = hinge
							end
						elseif (selid == 326) then -- Water Bucket
							aid = 9
						elseif (selid == 327) then -- Lava Bucket
							aid = 11
						end

						if allowed and alive and (dist < 10) and aid and idinfo[aid].block and (selcount > 0) and c1 and c1.loaded and c2 and c2.loaded then

							if inf.gamemode ~= 1 then
								inf.updateInventory = true
								if (selid == 326) or (selid == 327)  then
									selslot.id = 325
								elseif (selid == 259) then
									if not selslot.tag then
										selslot.tag = {}
									end
									selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
									if selslot.tag.Damage >= idinfo[selid].durability then
										selslot.tag.Damage = 0
										selslot.Count -= 1
										if selslot.Count <= 0 then
											local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
											if c and c.loaded then
												table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
											end
											table.remove(inf.Inventory,selnum)
											inf.updateInventory = true
										end
									end
								else
									selslot.Count = selslot.Count - 1
									if selslot.Count <= 0 then
										table.remove(inf.Inventory,selnum)
									end
								end
							end

							if selid == 259 then
								local t = b1
								if t and (t == 46) then
									c1:Set(pos1.X%16,pos1.Y,pos1.Z%16,0,true)
									table.insert(upCh(c2).blockdata,{Vector3.new(pos2.X%16,pos2.Y,pos2.Z%16),b2 or 0})
									table.insert(upCh(c2).events,{"sound",Vector3.new(pos1.X + .5,pos1.Y + .5,pos1.Z + .5),soundinfo.entity.tnt.primed})
									local iteme = createEntity(Vector3.new(pos1.X + .5,pos1.Y + .5,pos1.Z + .5),"tnt",c1.Dimension)
									if iteme then
										iteme.Motion = Vector3.new((math.random()-.5)*0.05,0.1,(math.random()-.5)*0.05)
										iteme.Fuse = 80
										iteme:Initialize()
									end
								else
									c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop)
								end
							elseif (selid == 324) or (selid == 330) or (selid == 489)  then
								-- lower
								local prop1 = {
									facing = prop.facing,
									hinge = prop.hinge,
									half = "lower"
								}
								c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop1)
								-- upper
								local prop2 = {
									facing = prop.facing,
									hinge = prop.hinge,
									half = "upper"
								}
								c2:Set(pos2.X%16,pos2.Y + 1,pos2.Z%16,aid,true,prop2)
							else
								c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop)
							end
							if (selid == 326) or (selid == 327) then
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.item.bucket.empty,i})
							elseif (selid == 259) then
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.item.flintandsteel.use,i})
							else
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.block[idinfo[aid].sound].place,i})
							end

						elseif c2 and c2.loaded then
							inf.updateInventory = true
							table.insert(upCh(c2).blockdata,{Vector3.new(pos2.X%16,pos2.Y,pos2.Z%16),b2 or 0}) -- error block
						end

					elseif state.ibreak then

						local pos = state.targetBlock
						local dist = (pos - inf.Pos).Magnitude

						local b,c = getBlock(pos.X,pos.Y,pos.Z,inf.Dimension)

						local function sendErrorBlock()
							if c and c.loaded then table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0}) end -- error block
							inf.updateInventory = true
						end

						if alive and (dist < 10) and c and c.loaded and b and (b ~= 0) then
							if inf.gamemode == 1 then
								breakBlock(i,inf,b,c,pos)
							else
								if inf.targetblock ~= pos then
									inf.breaking = nil
									inf.targethardness = nil
								end

								local hardness = (idinfo[b] and idinfo[b].hardness or math.huge)

								local harvest,speed,damage = canHarvest(selslot,b)
								if harvest then
									hardness *= 30
								else
									hardness *= 100
								end

								hardness = hardness / (speed or 1)

								if state.ibroken and ((inf.breaking or 0) > (hardness - 5)) then
									inf.breaking = nil
									inf.targetblock = nil
									if c and c.loaded and b and (b ~= 0) then
										breakBlock(i,inf,b,c,pos,harvest)
										for i,v in pairs(SpawnPoints:GetChildren()) do
											if v.Value == pos then
												v:Destroy()
											end
										end
										if selslot and (damage > 0) then
											if not selslot.tag then
												selslot.tag = {}
											end
											selslot.tag.Damage = (selslot.tag.Damage or 0) + damage
											if selslot.tag.Damage >= idinfo[selid].durability then
												selslot.tag.Damage = 0
												selslot.Count -= 1
												if selslot.Count <= 0 then
													table.remove(inf.Inventory,selnum)
													inf.updateInventory = true
												end
											end
										end
									else
										sendErrorBlock()
									end
								else
									inf.targetblock = pos
									inf.targethardness = hardness
									inf.breaking = (inf.breaking or 0) + 99

									local stage = math.min(9,math.floor(inf.breaking/hardness*10))

									table.insert(upCh(c).events,{"break",i,Vector3.new(pos.X,pos.Y,pos.Z),stage})
								end
							end
						else
							sendErrorBlock()
						end

					elseif state.iuse then

						local pos1 = state.targetBlock
						local pos2 = state.targetBlockNor and (state.targetBlock + state.targetBlockNor)
						local pos3 = state.targetFluid
						local b1,c1,prop1
						local b2,c2,prop2
						local b3,c3,prop3
						if pos1 then
							b1,c1 = getBlock(pos1.X,pos1.Y,pos1.Z,inf.Dimension)
							prop1 = b1 and indexVector(c1.propdata,pos1.X%16,pos1.Y,pos1.Z%16)
						end
						if pos2 then
							b2,c2 = getBlock(pos2.X,pos2.Y,pos2.Z,inf.Dimension)
							prop2 = b2 and indexVector(c2.propdata,pos2.X%16,pos2.Y,pos2.Z%16)
						end
						if pos3 then
							b3,c3 = getBlock(pos3.X,pos3.Y,pos3.Z,inf.Dimension)
							prop3 = b3 and indexVector(c3.propdata,pos3.X%16,pos3.Y,pos3.Z%16)
						end

						local function sendErrorBlock()
							local function rep(b,c,pos,prop)
								if b then
									if c and c.loaded then table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop}) end
								end
							end
							rep(b1,c1,pos1,prop1)
							rep(b2,c2,pos2,prop2)
							rep(b3,c3,pos3,prop3)
							inf.updateInventory = true
						end

						if selid == 325 then -- Bucket
							local pos = pos3
							local dist = (pos - inf.Pos).Magnitude
							if alive and (dist < 10) and c3 and c3.loaded and b3 and ((b3 == 9) or (b3 == 11)) then
								c3:Set(pos.X%16,pos.Y,pos.Z%16,0,true)
								table.insert(upCh(c3).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.item.bucket.fill,i})
								if selcount > 1 then
									local inside = false
									for i=0,35 do
										if not getSlotContent(getSlot(inf.Inventory,i))[2] then
											setSlot(inf.Inventory,i,{
												id = lavaid[b3] and 327 or 326,
												Count = 1
											})
											inside = true
											break
										end
									end
									if not inside then
										local iteme = createEntity(Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z),"item",inf.Dimension)
										if iteme then
											iteme.Motion = CFrame.fromEulerAnglesYXZ(inf.Rotation.Y,inf.Rotation.X,0).LookVector*0.5
											iteme.Item = {
												Count = 1,
												id = lavaid[b3] and 327 or 326
											}
											iteme.PickupDelay = 10
											iteme:Initialize()
										end
									end
									selslot.Count = selcount - 1
								else
									selslot.id = lavaid[b3] and 327 or 326
								end
								inf.updateInventory = true

							else
								sendErrorBlock()
							end
						elseif idinfo[selid].tool and (idinfo[selid].type == "farmingtool") then -- Farming Tool
							local pos = pos1
							local dist = (pos - inf.Pos).Magnitude
							if alive and (dist < 10) and c1 and c1.loaded and b1 and ((b1 == 2) or (b1 == 3)) then
								c1:Set(pos.X%16,pos.Y,pos.Z%16,60,true)
								indexVector(c1.propdata,pos.X%16,pos.Y,pos.Z%16,{
									moisture = 0
								})
								table.insert(upCh(c1).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.gravel.place,i})

								if math.random(1,8) == 1 then
									local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + 1.2,pos.Z + .5),"item",inf.Dimension)
									if iteme then
										iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
										iteme.Item = {
											Count = 1,
											id = 295,
										}
										iteme.PickupDelay = 10
										iteme:Initialize()
									end
								end

								if not selslot.tag then
									selslot.tag = {}
								end
								selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
								if selslot.tag.Damage >= idinfo[selid].durability then
									selslot.tag.Damage = 0
									selslot.Count -= 1
									if selslot.Count <= 0 then
										local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
										if c and c.loaded then
											table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
										end
										table.remove(inf.Inventory,selnum)
										inf.updateInventory = true
									end
								end

							else
								sendErrorBlock()
							end

						else
							sendErrorBlock()
						end

					elseif state.iinteract then

						local pos = state.targetBlock
						local b,c = getBlock(pos.X,pos.Y,pos.Z,inf.Dimension)
						local prop
						if c then
							prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
						end
						local dist = (pos - inf.Pos).Magnitude
						local slot =getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
						if slot and slot.Count ~= 0 then
							if 	slot.id == 405  then
								local cur = inf.Pos 
								local ent = createEntity(Vector3.new(cur.X ,cur.Y+1.5,cur.Z),"enderpearl",inf.Dimension or "overworld")
								if ent then
									ent:Initialize(inf)
								end
								slot.Count = slot.Count - 1
								inf.updateInventory = true
							end

						end
						if alive and (dist < 10) and c and c.loaded and b and (b ~= 0) then
							if (b == 2) then
								local slot =getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
								if slot == nil or slot.Count == 0 then
									return
								end 

								if require(game.ReplicatedStorage.IDInfo)[slot.id] and require(game.ReplicatedStorage.IDInfo)[slot.id]["type"] == "shovel" then
									setBlock(pos.X,pos.Y,pos.Z,127)
									if slot == nil or slot.Count == 0 then
										return
									end
									if not slot.tag then
										slot.tag = {}
									end
									game.ReplicatedStorage.UpdatePlayer:FireClient(i,"ForceHit")
									selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
									if selslot.tag.Damage > require(game.ReplicatedStorage.IDInfo)[slot.id]["durability"] then
										selslot.tag.Damage = 0
										selslot.Count = 0
										local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
										if c and c.loaded then
											table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
										end
										table.remove(inf.Inventory,selnum)
										inf.updateInventory = true
									end
									inf.updateInventory = true
								end
							end
							if (b == 69696) then
								if inf.Dimesion == "nether" then -- explode when nether xd
									createExplosion(pos,4,true,inf.Dimension)
									return
								end
								if (workspace.WorldInfo.Clock.Value >= 11000) and (workspace.WorldInfo.Clock.Value <= 21812) then
									workspace.WorldInfo.Clock.Value = 0
									local data = {
										Message = tostring(i.Character.Name.." has sleep."),
										Name = "Server",
										Color = Color3.fromRGB(252, 216, 10),
										MessageColor = Color3.fromRGB(252, 216, 10)
									}
									game.ReplicatedStorage.ServerMessage:FireAllClients(i,data,true)
								else
									local spawnpoint = game.ReplicatedStorage.SpawnPoints
									--	if not spawnpoint:FindFirstChild(i.Character.Name) then
									--	local v = Instance.new("Vector3Value",spawnpoint)
									--	v.Value = pos
									--	v.Name = i.Name
									---end
									local hasRepeatedValue = false

									for _, v in pairs(spawnpoint:GetChildren()) do
										if v.Value == pos then
											hasRepeatedValue = true
											break
										end
									end

									if not hasRepeatedValue then
										local newSpawnPoint = Instance.new("Vector3Value")
										newSpawnPoint.Name = i.Name
										newSpawnPoint.Value = pos
										newSpawnPoint.Parent = spawnpoint
									end
								end
							end

							if (b == 64) or (b == 489) and prop then
								local open = not prop.open
								prop.open = open
								c:Set(pos.X%16,pos.Y,pos.Z%16,b,true,prop)
								table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),open and soundinfo.block.wooden_door.open or soundinfo.block.wooden_door.close,i})

								local half = prop.half or "lower"
								if b == 64 then
									if half == "lower" then
										local b2 = getBlock(pos.X,pos.Y + 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y + 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y + 1,pos.Z%16,b,true,prop2)
											end
										end
									else
										local b2 = getBlock(pos.X,pos.Y - 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y - 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y - 1,pos.Z%16,b,true,prop2)
											end
										end
									end
								else
									if half == "lower" then
										local b2 = getBlock(pos.X,pos.Y + 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y + 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y + 1,pos.Z%16,489,true,prop2)
												print("set")
											end
										end
									else
										local b2 = getBlock(pos.X,pos.Y - 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y - 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y - 1,pos.Z%16,489,true,prop2)
												print("set")
											end
										end
									end
								end
							else
								table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop})
							end
						else
							table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop})
						end

					elseif state.ieat then
						if alive and inf.Health and (inf.Player:WaitForChild("Hunger").Value < 96) then
							if selid and idinfo[selid].food then
								if state.ieaten and ((inf.eating or 0) >= 29) then
									inf.eating = nil
									selslot.Count -= 1
									if selslot.Count <= 0 then
										table.remove(inf.Inventory,selnum)
									end
									if selid == 331 then
										spawn(function()
											local v1 = game.Players:FindFirstChild(state.plrname or "None")

											if v1.Character then
												if not v1.Character:FindFirstChild("Venenous") then
													Instance.new("BoolValue",v1.Character).Name = "Venenous"
													for i = 1,math.random(3,12) do
														wait(1)
														if inf.Health > 0.51 then
															inf.Health = inf.Health - 0.5
														else
															break
														end
													end

													if v1.Character then
														inf.Health = inf.Health + 0.5
														for i,v5 in pairs(v1.Character:GetChildren()) do
															if v5.Name == "Venenous" then
																v5:Destroy()
															end
														end
													end
												end
											else
												--"Failure to load damage for rotten")
											end
										end)
									end
									if inf.Health < 20 then
										--	inf.Health = math.min(inf.Health + (idinfo[selid].restore or 0),20)

									end
									if inf.Player:WaitForChild("Hunger").Value < 96 then
										local res = 20
										if idinfo[selid].restore then
											res = idinfo[selid].restore/.25
										end
										inf.Player:WaitForChild("Hunger").Value = inf.Player:WaitForChild("Hunger").Value + (res or 0)
									end
									local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
									if c then
										table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.player.burp})
									end
									inf.updateInventory = true
									--game.ReplicatedStorage.Update:FireClient(i,"RenderInventory")
								else
									inf.eating = (inf.eating or 0) + 1
								end
							else
								inf.eating = nil
							end
						else
							inf.eating = nil
						end

					end

					if state.iswing then
						addEvent(inf.Dimension,"anim",inf,0)
					end

					if inf.breaking and not state.ibreak then
					--	inf.breaking = nil
					--	inf.targethardness = nil
						--inf.targetblock = nil
					end
					if inf.eating and not state.ieat then
						inf.eating = nil
					end

					-- Events

					local tob = state.openblock
					local lob = inf.lastopenblock

					local b1,c1
					local b2,c2

					if tob then
						b1,c1 = getBlock(tob.X,tob.Y,tob.Z,inf.Dimension)
					end
					if lob then
						b2,c2 = getBlock(lob.X,lob.Y,lob.Z,inf.Dimension)
					end

					if (b1 == 54) and (b2 ~= 54) then
						table.insert(upCh(c1).events,{"chest",tob.X,tob.Y,tob.Z,true})
						table.insert(upCh(c1).events,{"sound",Vector3.new(tob.X+.5,tob.Y+.5,tob.Z+.5),soundinfo.block.chest.open})
					elseif (b1 ~= 54) and (b2 == 54) then
						table.insert(upCh(c2).events,{"chest",lob.X,lob.Y,lob.Z,false})
						table.insert(upCh(c2).events,{"sound",Vector3.new(lob.X+.5,lob.Y+.5,lob.Z+.5),soundinfo.block.chest.close})
					end

					inf.lastopenblock = tob

					inf.SelectedItem = deepcopy(selslot)

					-- Physics

					local function check()
						if (not inf.changeMotion) and (state.pos) then
							if math.sqrt((inf.Pos.X - state.pos.X)^2 + (inf.Pos.Z - state.pos.Z)^2) < 1 then
								if math.abs(inf.Pos.Y - state.pos.Y) < 4 then
									return true
								end
							end
						end
					end

					if check() then
						inf.Pos = state.pos or inf.Pos
						inf.Motion = state.motion or inf.Motion
						inf.Rotation = state.rotation or inf.Rotation
					else
						inf.changeMotion = true
					end 


					inf.OnGround = state.onGround
				end)

				if not ok then
					i:Kick("Error while handling input from server.")
					warn("Player has been kicked due to error:",msg)
				end
			end

			v.free = math.huge
		end
	end
	debug.profileend()
	---- Weather

	local weather = workspace.WorldInfo.Weather.Value

	if not ticksBeforeWeather then
		ticksBeforeWeather = math.random(12000,180000)
	elseif ticksBeforeWeather > 0 then
		ticksBeforeWeather = ticksBeforeWeather - 1
	elseif ticksBeforeWeather <= 0 then
		if weather == 0 then
			weather = 1
			workspace.WorldInfo.Weather.Value = 1
			ticksBeforeWeather = math.random(12000,24000)
		else
			weather = 0
			workspace.WorldInfo.Weather.Value = 0
			ticksBeforeWeather = math.random(12000,180000)
		end
	end

	---- Getting Loaded Chunks

	local tickLC = {}

	for d,e in pairs(loadedChunks) do
		for _,c in pairs(e) do
			local level = getTicket(c.xPos,c.zPos,d)
			if level < 32 then
				if c.loaded and not c.generating then
					table.insert(tickLC,c)
				end
			end
		end
	end

	---- Spawn Cycle

	if #tickLC > 0 then
		-- Spawn animals

		if (ticks%400 == 0) then

			local count = 0
			for _,v in pairs(lastEntities) do
				if v.id == "pig" then
					count += 1
				end
			end
			if count < 8 then
				local c = tickLC[math.random(1,#tickLC)]
				local rX,rZ = math.random(0,15),math.random(0,15)
				for rY=heightlimit-1,1,-1 do
					if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
						attemptSpawn("pig",math.random(1,3),Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
						break
					end
				end

			end
			count = 0
			for _,v in pairs(lastEntities) do
				if v.id == "sheep" then
					count += 1
				end
			end
			if count < 8 then
				local c = tickLC[math.random(1,#tickLC)]
				local rX,rZ = math.random(0,15),math.random(0,15)
				for rY=heightlimit-1,1,-1 do
					if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
						attemptSpawn("sheep",math.random(1,3),Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
						break
					end
				end

			end
			count = 0
			for _,v in pairs(lastEntities) do
				if v.id == "cow" then
					count += 1
				end
			end
			if count < 8 then
				local c = tickLC[math.random(1,#tickLC)]
				local rX,rZ = math.random(0,15),math.random(0,15)
				for rY=heightlimit-1,1,-1 do
					if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
						attemptSpawn("cow",math.random(1,3),Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
						break
					end
				end

			end
			count = 0
			for _,v in pairs(lastEntities) do
				if v.id == "pigbaby" then
					count += 1
				end
			end
			if count < 8 then
				local c = tickLC[math.random(1,#tickLC)]
				local rX,rZ = math.random(0,15),math.random(0,15)
				for rY=heightlimit-1,1,-1 do
					if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
						local random = math.random(1,15)
						if random > 8.5 then
							attemptSpawn("pigbaby",math.random(1,3),Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
							break
						end
					end
				end

			end
		end

		-- Spawn monsters
		if (workspace.WorldInfo.Clock.Value >= 13188) and (workspace.WorldInfo.Clock.Value <= 22812) then
			local count = 0
			for _,v in pairs(lastEntities) do
				if v.id == "creeper" then
					count += 1
				end
			end
			if (count < 12) then
				local c = tickLC[math.random(1,#tickLC)]
				local rX,rZ = math.random(0,15),math.random(0,15)
				for rY=heightlimit-1,1,-1 do
					if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
						attemptSpawn("creeper",1,Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
						break
					end
				end
			end
			spawn(function()
				count = 0
				for _,v in pairs(lastEntities) do
					if v.id == "zombie" then
						count += 1
					end
				end
				if (count < 12) then
					local c = tickLC[math.random(1,#tickLC)]
					local rX,rZ = math.random(0,15),math.random(0,15)
					for rY=heightlimit-1,1,-1 do
						if isSolid(indexVector(c.blockdata,rX,rY,rZ)) then
							attemptSpawn("zombie",1,Vector3.new(c.xPos*16 + rX,rY,c.zPos*16 + rZ))
							break
						end
					end
				end
			end)
		end
	end

	---- Tick chunks

	debug.profilebegin("Ticking chunks")

	local ranTicks = {}
	for _,c in pairs(tickLC) do 

		-- Tile Entity Tick
		for _,v in pairs(c.tileentities) do
			if v.id == 61 then -- Furnace
				local change = false

				local lit = false

				if v.BurnTime and (v.BurnTime > 0) then
					change = true
					lit = true
				end
				v.BurnTime = math.max(0,(v.BurnTime or 0) - 1)

				if v.Items then
					local inp = getSlotContent(getSlot(v.Items,0))
					local fuel = getSlotContent(getSlot(v.Items,1))
					local out = getSlotContent(getSlot(v.Items,2))

					local result

					local smelt = false
					if inp[2] then
						result = smeltrecipes[1][inp[2]]
					end
					if result then
						if (not out[2]) or ((result == out[2]) and (out[1] < (idinfo[out[2]].Stack or 64))) then
							smelt = true
						end
					end

					local fuelr = fuel[2] and smeltrecipes[2][fuel[2]]

					if (v.BurnTime == 0) and smelt and fuelr then
						v.BurnTime = fuelr
						v.BurnTimeTotal = v.BurnTime

						local inps,num = getSlot(v.Items,1)
						if fuel[2] == 327 then
							inps.id = 325
						else
							inps.Count -= 1
							if inps.Count <= 0 then
								table.remove(v.Items,num)
							end
						end
					end

					if (v.BurnTime > 0) and smelt then
						v.CookTime = (v.CookTime or 0) + 1
						if v.CookTime >= v.CookTimeTotal then
							local inps,num = getSlot(v.Items,0)
							inps.Count -= 1
							if inps.Count <= 0 then
								table.remove(v.Items,num)
							end

							local outs = getSlot(v.Items,2)
							if not outs then
								setSlot(v.Items,2,{id = result,Count = 1})
							else
								outs.Count += 1
							end

							v.CookTime = 0
						end
						change = true
					elseif v.CookTime ~= 0 then
						v.CookTime = 0
						change = true
					end
				end

				if change then
					table.insert(tileentsets[c.Dimension],{v.x,v.y,v.z,v})
				end

				local old = indexVector(c.propdata,v.x%16,v.y,v.z%16)
				if lit and not (old and old.lit) then
					local prop = {
						facing = old and old.facing,
						lit = true
					}
					indexVector(c.propdata,v.x%16,v.y,v.z%16,prop)
					table.insert(blocksets[c.Dimension],{Vector3.new(v.x,v.y,v.z),61,prop})
				elseif (old and old.lit) and not lit then
					local prop = {
						facing = old and old.facing,
						lit = false
					}
					indexVector(c.propdata,v.x%16,v.y,v.z%16,prop)
					table.insert(blocksets[c.Dimension],{Vector3.new(v.x,v.y,v.z),61,prop})
				end
			end
		end

		-- Random
		for i=0,math.ceil(heightlimit/16-1) do
			for i2=1,3 do
				--debug.profilebegin("Indexing Vector")
				local x,y,z = c.xPos*16 + tickRan:NextInteger(0,15),i*16 + tickRan:NextInteger(0,15),c.zPos*16 + tickRan:NextInteger(0,15)
				local b1 = indexVector(c.blockdata,x%16,y,z%16)
				--debug.profileend()
				if b1 then
					if b1 == 2 then -- Grass Block
						local b3 = getBlock(x,y+1,z,c.Dimension)
						if b3 and isSolid(b3) and not (idinfo[b3] and idinfo[b3].transparent) then
							c:Set(x%16,y,z%16,3)
							table.insert(upCh(c).blockdata,{Vector3.new(x%16,y,z%16),3})
						else
							local x2,y2,z2 = x + math.random(-1,1),y + math.random(-3,1),z + math.random(-1,1)
							local bx,c = getBlock(x2,y2,z2,c.Dimension)
							local b2 = bx
							if b2 then
								if b2 == 3 then
									local b3 = getBlock(x2,y2+1,z2,c.Dimension)
									if not (b3 and (b3 ~= 0)) then
										c:Set(x2,y2,z2,2)
										table.insert(upCh(c).blockdata,{Vector3.new(x2%16,y2,z2%16),2})
										break
									end
								end
							end
						end
					elseif lavaid[b1] then -- Lava
						local dir = {
							Vector3.new(0,0,-1),
							Vector3.new(-1,0,0),
							Vector3.new(0,0,1),
							Vector3.new(1,0,0),
							Vector3.new(0,1,0),
							Vector3.new(0,-1,0),
						}
						for i=1,3 do
							local dx,dy,dz
							local j = math.random(1,34)
							if j > 9 then
								dy = 2
								dx = (j-10)%5
								dz = math.floor((j-10)/5)
							else
								dy = 1
								dx = (j-1)%3
								dz = math.floor((j-1)/3)
							end

							local pos1 = Vector3.new(x + dx,y + dy,z + dz)
							local b0,c0 = getBlock(pos1.X,pos1.Y,pos1.Z,c.Dimension)
							if c0 and c0.loaded and not (b0 and (b0 ~= 0)) then
								for i=1,6 do
									local pos = pos1 + dir[i]
									local b1,c1 = getBlock(pos.X,pos.Y,pos.Z,c.Dimension)
									if c1 and c1.loaded and b1 and (b1 ~= 0) then
										if idinfo[b1].catchlava then
											if math.random() < .75 then
												c0:Set(pos1.X%16,pos1.Y,pos1.Z%16,51,true,{
													age = 0
												})
												break
											end
										end
									end
								end
							end
						end
					elseif b1 == 18 then -- Leaves
						local open = {Vector3.new(x,y,z)}
						local closed = {}

						local decay = true
						for i=1,6 do
							local nextopen = {}
							for _,v in pairs(open) do
								local b,c = getBlock(v.X,v.Y,v.Z,c.Dimension)
								if b then
									if b == 17 then
										decay = false
										break
									elseif b == b1 then
										for i=1,6 do
											table.insert(nextopen,v + vecdir[i])
										end
									end	
								end
								table.insert(closed,v)
							end
							if not decay then break end

							open = nextopen
						end

						if decay then
							--local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
							c:Set(x%16,y,z%16,0,true)
							dropBlock(b1,c,Vector3.new(x,y,z))
						end
					elseif b1 == 356 then -- Leaves
						local open = {Vector3.new(x,y,z)}
						local closed = {}

						local decay = true
						for i=1,6 do
							local nextopen = {}
							for _,v in pairs(open) do
								local b,c = getBlock(v.X,v.Y,v.Z,c.Dimension)
								if b then
									if b == 998 then
										decay = false
										break
									elseif b == b1 then
										for i=1,6 do
											table.insert(nextopen,v + vecdir[i])
										end
									end	
								end
								table.insert(closed,v)
							end
							if not decay then break end

							open = nextopen
						end

						if decay then
							--local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
							c:Set(x%16,y,z%16,0,true)
							dropBlock(b1,c,Vector3.new(x,y,z))
						end
					elseif b1 == 347 then -- Spruce Leaves
						local open = {Vector3.new(x,y,z)}
						local closed = {}

						local decay = true
						for i=1,6 do
							local nextopen = {}
							for _,v in pairs(open) do
								local b,c = getBlock(v.X,v.Y,v.Z,c.Dimension)
								if b then
									if b == 348 then
										decay = false
										break
									elseif b == b1 then
										for i=1,6 do
											table.insert(nextopen,v + vecdir[i])
										end
									end	
								end
								table.insert(closed,v)
							end
							if not decay then break end

							open = nextopen
						end

						if decay then
							--local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
							c:Set(x%16,y,z%16,0,true)
							dropBlock(b1,c,Vector3.new(x,y,z))
						end
					elseif b1 == 360 then -- Swamp Leaves
						local open = {Vector3.new(x,y,z)}
						local closed = {}

						local decay = true
						for i=1,6 do
							local nextopen = {}
							for _,v in pairs(open) do
								local b,c = getBlock(v.X,v.Y,v.Z,c.Dimension)
								if b then
									if b == 17 then
										decay = false
										break
									elseif b == b1 then
										for i=1,6 do
											table.insert(nextopen,v + vecdir[i])
										end
									end	
								end
								table.insert(closed,v)
							end
							if not decay then break end

							open = nextopen
						end

						if decay then
							--local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
							c:Set(x%16,y,z%16,0,true)
							dropBlock(b1,c,Vector3.new(x,y,z))
						end
					elseif b1 == 59 then -- Wheat Crops
						local points = 0

						local stage = 0
						do local prop = indexVector(c.propdata,x%16,y,z%16)
							stage = prop and prop.age or 0
						end

						if stage < 7 then

							-- Farmland
							do local bf = indexVector(c.blockdata,x%16,y-1,z%16)
								if bf and (bf == 60) then
									local prop = indexVector(c.propdata,x%16,y-1,z%16)
									local moisture = prop and prop.moisture or 0
									if moisture == 7 then
										points += 4
									else
										points += 2
									end
								end
							end

							-- Blocks around farmland
							local dx,dz = 0,1
							local dir = 0
							local level = 1
							for i=1,8 do
								local bx,cx = getBlock(x + dx,y-1,z + dz,c.Dimension)
								local b2 = bx
								if b2 then
									if b2 == 60 then
										local prop = indexVector(cx.propdata,(x + dx)%16,y-1,(z + dz)%16)
										local moisture = prop and prop.moisture or 0
										if moisture == 7 then
											points += .75
										else
											points += .25
										end
									end
								end

								if dir == 0 then
									dx = dx + 1
									if dx == level then
										dir += 1
									end
								elseif dir == 1 then
									dz = dz - 1
									if dz == -level then
										dir += 1
									end
								elseif dir == 2 then
									dx = dx - 1
									if dx == -level then
										dir += 1
									end
								elseif dir == 3 then
									dz = dz + 1
									if dz == level then
										dir = 0
									end
								end
							end

							-- Blocks around the crop
							local acceptable = true
							local sur = {}

							local dx,dz = 0,1
							local dir = 0
							local level = 1
							for i=1,8 do
								local bx,cx = getBlock(x + dx,y,z + dz,c.Dimension)
								local b2 = bx
								if b2 then
									if b2 == 59 then
										if i%2 == 0 then
											acceptable = false
											break
										else
											sur[i] = true
										end
									end
								end

								if dir == 0 then
									dx = dx + 1
									if dx == level then
										dir += 1
									end
								elseif dir == 1 then
									dz = dz - 1
									if dz == -level then
										dir += 1
									end
								elseif dir == 2 then
									dx = dx - 1
									if dx == -level then
										dir += 1
									end
								elseif dir == 3 then
									dz = dz + 1
									if dz == level then
										dir = 0
									end
								end
							end

							if acceptable then
								if sur[1] then
									if sur[5] then
										if sur[3] or sur[7] then
											acceptable = false
										end
									else
										acceptable = false
									end
								elseif sur[5] then
									if sur[1] then
										if sur[3] or sur[7] then
											acceptable = false
										end
									else
										acceptable = false
									end

								elseif sur[3] then
									if sur[7] then
										if sur[1] or sur[5] then
											acceptable = false
										end
									else
										acceptable = false
									end
								elseif sur[7] then
									if sur[3] then
										if sur[1] or sur[5] then
											acceptable = false
										end
									else
										acceptable = false
									end
								end
							end

							if not acceptable then
								points /= 2
							end

							-- Calculate probability
							if math.random() < (1/(math.floor(25/points) + 1)) then
								local prop = {
									age = stage + 1
								}
								indexVector(c.propdata,x%16,y,z%16,prop)
								table.insert(blocksets[c.Dimension],{Vector3.new(x,y,z),59,prop})
							end
						end
					elseif b1 == 60 then -- Farmland
						local water = false

						local prop = indexVector(c.propdata,x%16,y,z%16)
						local moisture = prop and prop.moisture or 0

						for dy=0,1 do
							local dx,dz = 0,1
							local level = 1
							local dir = 0
							for i=1,80 do
								if i == (((level*2)+1)^2) then
									level += 1
									dz += 1
								end

								local bx,c = getBlock(x + dx,y + dy,z + dz,c.Dimension)
								local b2 = bx
								if b2 then
									if waterid[b2] then
										water = true
										break
									end
								end

								if dir == 0 then
									dx = dx + 1
									if dx == level then
										dir += 1
									end
								elseif dir == 1 then
									dz = dz - 1
									if dz == -level then
										dir += 1
									end
								elseif dir == 2 then
									dx = dx - 1
									if dx == -level then
										dir += 1
									end
								elseif dir == 3 then
									dz = dz + 1
									if dz == level then
										dir = 0
									end
								end
							end
							if water then
								break
							end

						end

						if water then
							if moisture ~= 7 then
								local prop = {
									moisture = 7
								}
								indexVector(c.propdata,x%16,y,z%16,prop)
								table.insert(blocksets[c.Dimension],{Vector3.new(x,y,z),60,prop})
							end
						else
							if moisture > 0 then
								local prop = {
									moisture = moisture - 1
								}
								indexVector(c.propdata,x%16,y,z%16,prop)
								table.insert(blocksets[c.Dimension],{Vector3.new(x,y,z),60,prop})
							else
								local b0 = indexVector(c.blockdata,x%16,y+1,z%16)
								if b0 and (b0 == 59) then
									local prop = {
										moisture = 0
									}
									indexVector(c.propdata,x%16,y,z%16,prop)
									table.insert(blocksets[c.Dimension],{Vector3.new(x,y,z),60,prop})
								else
									c:Set(x%16,y,z%16,3,true)
									table.insert(blocksets[c.Dimension],{Vector3.new(x,y,z),3})
								end
							end
						end
					end
				end
			end
		end
	end
	-- Tick scheduled updates
	for d,su in pairs(scheduledupdates) do
		local newscheduledupdates = {}
		while #su > 0 do
			local v = table.remove(su,1)
			if v[2] <= 0 then
				table.insert(blockupdates[d],v[1])

				local removal = {}
				for _,v2 in pairs(su) do
					if v2[1] == v[1] then
						table.insert(removal,v2)
					end
				end
				for _,v2 in pairs(removal) do
					table.remove(su,table.find(su,v2))
				end
			else
				v[2] -= 1
				table.insert(newscheduledupdates,v)
			end
		end
		scheduledupdates[d] = newscheduledupdates
	end
	-- Do block updates
	for d,e in pairs(blockupdates) do
		local blockupdates2 = {}
		for i,v in pairs(e) do
			blockupdates2[i] = v
		end
		blockupdates[d] = {}
		local setqueue = {}
		local done = {}
		for i,v in pairs(blockupdates2) do
			if not table.find(done,v) then
				local b,c = getBlock(v.X,v.Y,v.Z,d)
				if c and c.loaded and b then
					local blockhasgravity = false
					if b then
						local idInfo = require(game.ReplicatedStorage.IDInfo)
						local blockInfo = idInfo[b]

						-- Check if blockInfo exists and has the 'gravity' property
						if blockInfo and blockInfo.gravity ~= nil and blockInfo.gravity == true  then
							blockhasgravity = true
						else
							blockhasgravity = false
						end
					end

					if (b == 50) then -- Face connected blocks
						local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
						local facing = prop and prop.facing or "top"
						local dir = 6
						if facing == "north" then
							dir = 3
						elseif facing == "west" then
							dir = 4
						elseif facing == "south" then
							dir = 1
						elseif facing == "east" then
							dir = 2
						end
						local pos2 = Vector3.new(v.X,v.Y,v.Z) + vecdir[dir]

						local b1,c1 = getBlock(pos2.X,pos2.Y,pos2.Z,d)
						if not (b1 and isSolid(b1)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z),prop)
						end
					elseif (b == 6) then -- Sapling
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 2) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						else
							spawn(function()
								local c1 = math.random(40,120)
								local pos2 = v
								for i1 = 1,c1 + 5 do
									if i1 == c1 then
										local g = getBlock(pos2.X, pos2.Y, pos2.Z,"overworld")
										if g == 0 or g ~= 6 then
											--"Failed to grow tree: No saplings")
											break
										end

										local birchrandom = math.random(1,100)


										for i=0,5 do

											setBlock(pos2.X,pos2.Y + i,pos2.Z,17)

										end
										-- Define the position of the center of the cube

										-- Define the size of the cube
										-- Define the position of the center of the cube

										-- Define the size of the cube
										-- Define the position of the center of the baseplate

										-- Define the size of the baseplate
										local baseplateSize = 2  -- You can adjust this value to change the size of the baseplate

										-- Loop through the x and z coordinates to create a baseplate
										for offsetX = -baseplateSize, baseplateSize do
											for offsetZ = -baseplateSize, baseplateSize do
												-- Calculate the new position based on the offsets
												local newX = pos2.X + offsetX

												local newZ = pos2.Z + offsetZ

												-- Set the block at the new position to ID 18 (you can change this to the desired block ID)
												setBlock(newX, pos2.Y + 3, newZ, 18)
											end
										end
										for offsetX = -baseplateSize, baseplateSize do
											for offsetZ = -baseplateSize, baseplateSize do
												-- Calculate the new position based on the offsets
												local newX = pos2.X + offsetX

												local newZ = pos2.Z + offsetZ

												-- Set the block at the new position to ID 18 (you can change this to the desired block ID)
												setBlock(newX, pos2.Y + 2, newZ, 18)
											end
										end
										-- id
										setBlock(pos2.X + 1, pos2.Y + 4, pos2.Z, 18)
										setBlock(pos2.X - 1, pos2.Y + 4, pos2.Z, 18)
										setBlock(pos2.X, pos2.Y + 4, pos2.Z - 1, 18)
										setBlock(pos2.X - 1, pos2.Y + 4, pos2.Z + 1, 18)
										-- Leaves thingie on top of tree
										setBlock(pos2.X + 1, pos2.Y + 4, pos2.Z - 1, 18)
										setBlock(pos2.X + 1, pos2.Y + 4, pos2.Z , 18)
										setBlock(pos2.X - 1, pos2.Y + 4, pos2.Z + 1, 18)
										setBlock(pos2.X - 1, pos2.Y + 4, pos2.Z - 1, 18)
										setBlock(pos2.X + 1, pos2.Y + 4, pos2.Z + 1, 18)
										-- end leaves
										-- well the leaves at the top so it doenst just appear wood ig
										setBlock(pos2.X, pos2.Y + 4, pos2.Z + 1, 18)
										setBlock(pos2.X + 1, pos2.Y + 5, pos2.Z, 18)
										setBlock(pos2.X - 1, pos2.Y + 5, pos2.Z, 18)
										setBlock(pos2.X, pos2.Y + 5, pos2.Z - 1, 18)
										setBlock(pos2.X, pos2.Y + 5, pos2.Z + 1, 18)
										setBlock(pos2.X, pos2.Y + 5, pos2.Z, 18)
										break
									end
									wait(.1)
								end
							end)
						end
					elseif (b == 100) or (b == 99)  then -- Flowers?
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 2) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 31)   then -- Grass
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 2) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 39)   then -- Grass
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 2) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end	
					elseif (b == 359)   then -- Grass
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 358) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 357)   then -- dead bush
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 12)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 351)   then -- Grass
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 346) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 352)   then -- Grass
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not ((b1 == 346) or (b1 == 3)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z))
						end
					elseif (b == 123) then -- Cactus why not
						local function countAdjacentCacti(x, y, z, d)
							local count = 0
							for i = -1, 1 do
								for j = -1, 1 do
									for k = -1, 1 do
										if not (i == 0 and j == 0 and k == 0) then
											local b1, _ = getBlock(x + i, y + j, z + k, d)
											if b1 == 123 then
												count = count + 1
											end
										end
									end
								end
							end
							return count
						end

						local b1, c1 = getBlock(v.X, v.Y - 1, v.Z, d)
						if not (b1 == 12 or b1 == 123) then
							c:Set(v.X % 16, v.Y, v.Z % 16, 0, true)
							dropBlock(123, c, Vector3.new(v.X, v.Y, v.Z))
						end

						b1, c1 = getBlock(v.X, v.Y + 1, v.Z, d)
						if b1 == 123 and countAdjacentCacti(v.X, v.Y + 1, v.Z, d) > 3 then
							c:Set(v.X % 16, v.Y + 1, v.Z % 16, 0, true)
							dropBlock(123, c, Vector3.new(v.X, v.Y + 1, v.Z))
						end

						b1, c1 = getBlock(v.X, v.Y - 3, v.Z, d)
						if b1 == 123  then
							c:Set(v.X % 16, v.Y - 3, v.Z % 16, 0, true)
							dropBlock(123, c, Vector3.new(v.X, v.Y - 3, v.Z))
						end


					elseif (b == 64) or (b == 73) or (b == 489) then -- Doors
						local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
						local half = prop and prop.half or "lower"

						if half == "upper" then
							local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
							if (b1 ~= b) then
								c:Set(v.X%16,v.Y,v.Z%16,0,true)
							end
						else
							local b1,c1 = getBlock(v.X,v.Y + 1,v.Z,d)
							if (b1 ~= b) then
								c:Set(v.X%16,v.Y,v.Z%16,0,true)
								dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z),prop)
							end
						end
					elseif (b == 85) then -- Fences
						local propl = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)

						local prop = {}
						local change = false

						for i=1,4 do
							local dir = vecdir[i]
							local b1,c1 = getBlock(v.X + dir.X,v.Y,v.Z + dir.Z,d)
							local bo = false
							if b1 and isSolid(b1) then
								bo = true
								prop[vecdirnames[i]] = true
							else
								prop[vecdirnames[i]] = false
							end
							if propl and (propl[vecdirnames[i]] ~= bo) then
								change = true
							end
						end

						if change or not propl then
							c:Set(v.X%16,v.Y,v.Z%16,85,true,prop)
						end
					elseif (b == 59) then -- Wheat Crops
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if b1 ~= 60 then
							local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z),prop)
						end
					elseif (b == 175) then -- Ladder
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if b1 == 0 then
							local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
							dropBlock(b,c,Vector3.new(v.X,v.Y,v.Z),prop)
						end
					elseif (b == 12) or (b == 13) or blockhasgravity  then
						local b1 = getBlock(v.X,v.Y - 1,v.Z,d)
						if not (b1 and (b1 ~= 0) and isSolid(b1)) then
							local ent = createEntity(Vector3.new(v.X + .5,v.Y,v.Z + .5),"falling_block",c.Dimension)
							if ent then
								ent.BlockState = {
									id = b
								}
								ent:Initialize()
							end
							--c:Set(v.X%16,v.Y,v.Z%16,0,true)
							table.insert(setqueue,{c,v.X%16,v.Y,v.Z%16,0})
							table.insert(upCh(c).blockdata,{Vector3.new(v.X%16,v.Y,v.Z%16),0})
						end
					elseif b == 51 then
						local portal = false

						local b0,c0 = getBlock(v.X,v.Y - 1,v.Z,d)
						if b0 == 49 then
							local b1,c1 = getBlock(v.X + 1,v.Y,v.Z,d)
							local b2,c2 = getBlock(v.X + 1,v.Y - 1,v.Z,d)

							local b3,c3 = getBlock(v.X,v.Y,v.Z + 1,d)
							local b4,c4 = getBlock(v.X,v.Y - 1,v.Z + 1,d)

							b1 = b1 or 0
							b2 = b2 or 0
							b3 = b3 or 0
							b4 = b4 or 0

							local origin = nil
							local axis = 0
							if b1 == 49 then
								origin = Vector3.new(v.X,v.Y,v.Z)
							elseif ((b1 == 0) or (b1 == 51)) and (b2 == 49) then
								local b5,c5 = getBlock(v.X + 2,v.Y,v.Z,d)
								if b5 == 49 then
									origin = Vector3.new(v.X + 1,v.Y,v.Z)
								end
							elseif b3 == 49 then
								axis = 1
								origin = Vector3.new(v.X,v.Y,v.Z)

							elseif ((b3 == 0) or (b3 == 51)) and (b4 == 49) then
								axis = 1
								local b5,c5 = getBlock(v.X,v.Y,v.Z + 2,d)
								if b5 == 49 then
									origin = Vector3.new(v.X,v.Y,v.Z + 1)
								end
							end

							if origin then
								local fail = false
								local v = origin
								for dy=0,2 do
									for dn=0,1 do
										if axis == 0 then
											local b1,c1 = getBlock(v.X - dn,v.Y + dy,v.Z,d)
											if (b1 == 0) or (b1 == 51) then
												if dn == 0 then
													local b2,c2 = getBlock(v.X + 1,v.Y + dy,v.Z,d)
													if b2 ~= 49 then
														fail = true
														break
													end
												else
													local b2,c2 = getBlock(v.X - 2,v.Y + dy,v.Z,d)
													if b2 ~= 49 then
														fail = true
														break
													end
												end
											else
												fail = true
												break
											end
										else
											local b1,c1 = getBlock(v.X,v.Y + dy,v.Z - dn,d)
											if (b1 == 0) or (b1 == 51) then
												if dn == 0 then
													local b2,c2 = getBlock(v.X,v.Y + dy,v.Z + 1,d)
													if b2 ~= 49 then
														fail = true
														break
													end
												else
													local b2,c2 = getBlock(v.X,v.Y + dy,v.Z - 2,d)
													if b2 ~= 49 then
														fail = true
														break
													end
												end
											else
												fail = true
												break
											end
										end
										if (dy == 2) then
											if axis == 0 then
												local b2,c2 = getBlock(v.X - dn,v.Y + 3,v.Z,d)
												if b2 ~= 49 then
													fail = true
													break
												end
											else
												local b2,c2 = getBlock(v.X,v.Y + 3,v.Z - dn,d)
												if b2 ~= 49 then
													fail = true
													break
												end
											end
										end
										if (dy == 2) and (dn == 1) then
											portal = true
										end
									end
									if fail then
										break
									end
								end
							end

							if portal then
								local v = origin
								for dy=0,2 do
									for dn=0,1 do
										if axis == 0 then
											local x,y,z = v.X - dn,v.Y + dy,v.Z
											local b1,c1 = getBlock(x,y,z,d)
											c1:Set(x%16,y,z%16,90,true,{
												axis = "x"
											})
										else
											local x,y,z = v.X,v.Y + dy,v.Z - dn
											local b1,c1 = getBlock(x,y,z,d)
											c1:Set(x%16,y,z%16,90,true,{
												axis = "z"
											})
										end
									end
								end
							end
						end

						if not portal then
							local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
							local age = prop and prop.age or 0

							local dir = {
								Vector3.new(0,0,-1),
								Vector3.new(-1,0,0),
								Vector3.new(0,0,1),
								Vector3.new(1,0,0),
								Vector3.new(0,1,0),
								Vector3.new(0,-1,0),
							}
							for x=-1,1 do
								for y=-1,4 do
									for z=-1,1 do
										local pos1 = Vector3.new(v.X + x,v.Y + y,v.Z + z)
										local b0,c0 = getBlock(pos1.X,pos1.Y,pos1.Z,d)
										if c0 and c0.loaded and not (b0 and (b0 ~= 0)) then
											for i=1,6 do
												local pos = pos1 + dir[i]
												local b1,c1 = getBlock(pos.X,pos.Y,pos.Z,d)
												if c1 and c1.loaded and b1 and (b1 ~= 0) then
													local spread = idinfo[b1].spread
													if spread then
														if math.random() < (spread/10000) then
															c0:Set(pos1.X%16,pos1.Y,pos1.Z%16,51,true,{
																age = 0
															})
															break
														end
													end
												end
											end
										end
									end
								end
							end

							local adjf = 6
							for i=1,6 do
								local pos = v + dir[i]
								local b1,c1 = getBlock(pos.X,pos.Y,pos.Z,d)
								if c1 and c1.loaded and b1 and (b1 ~= 0) and (b1 ~= 51) then
									local fire = idinfo[b1].fire
									if fire then
										if math.random() < (fire/10000) then
											adjf -= 1
											c1:Set(pos.X%16,pos.Y,pos.Z%16,0,true)

											if b1 == 46 then
												table.insert(upCh(c1).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.entity.tnt.primed})
												local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"tnt",c1.Dimension)
												if iteme then
													iteme.Motion = Vector3.new((math.random()-.5)*0.05,0.1,(math.random()-.5)*0.05)
													iteme.Fuse = 80
													iteme:Initialize()
												end
											end
										end
									end
								else
									adjf -= 1
								end
							end
							if adjf <= 0 then
								c:Set(v.X%16,v.Y,v.Z%16,0,true)
							elseif (age < 15) and (math.random(1,3) == 1) then
								c:Set(v.X%16,v.Y,v.Z%16,51,false,{
									age = age + 1
								})
							elseif age == 15 then
								local b0 = getBlock(v.X,v.Y-1,v.Z,d)
								if (not (b0 and (b0 ~= 0) and idinfo[b0].fire)) and (math.random(1,4) == 1) then
									c:Set(v.X%16,v.Y,v.Z%16,0,true)
								end
							end
							table.insert(scheduledupdates[c.Dimension],{v,19})
						end
					elseif b == 90 then
						local b0,c0 = getBlock(v.X,v.Y + 1,v.Z,d)
						local b1,c1 = getBlock(v.X,v.Y - 1,v.Z,d)
						local b2,c2
						local b3,c3

						local prop = indexVector(c.propdata,v.X%16,v.Y,v.Z%16)
						local axis = prop and prop.axis or "x"
						if axis == "z" then
							b2,c2 = getBlock(v.X,v.Y,v.Z - 1,d)
							b3,c3 = getBlock(v.X,v.Y,v.Z + 1,d)
						else
							b2,c2 = getBlock(v.X - 1,v.Y,v.Z,d)
							b3,c3 = getBlock(v.X + 1,v.Y,v.Z,d)
						end
						if not ((b0 == 49) or (b0 == 90)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
						elseif not ((b1 == 49) or (b1 == 90)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
						elseif not ((b2 == 49) or (b2 == 90)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
						elseif not ((b3 == 49) or (b3 == 90)) then
							c:Set(v.X%16,v.Y,v.Z%16,0,true)
						end
					elseif (waterid[b]) then
						table.insert(liquidticks[c.Dimension],{4,v})
					elseif (lavaid[b]) then
						local dir = {
							Vector3.new(0,0,-1),
							Vector3.new(-1,0,0),
							Vector3.new(0,0,1),
							Vector3.new(1,0,0),
						}

						local safe = true
						for i=1,4 do
							local pos = v + dir[i]
							local b1,c1 = getBlock(pos.X,pos.Y,pos.Z,d)
							if c1 and c1.loaded and (b1 and waterid[b1]) then
								safe = false
								if b == 11 then
									table.insert(setqueue,{c,v.X%16,v.Y,v.Z%16,49})
								else
									table.insert(setqueue,{c,v.X%16,v.Y,v.Z%16,4})
								end
								--"extinguish1")
								table.insert(upCh(c).events,{"sound",Vector3.new(v.X + .5,v.Y + .5,v.Z + .5),soundinfo.block.lava.extinguish})
							end
						end
						if safe then
							table.insert(liquidticks[c.Dimension],{29,v})
						end
					end
				end
				table.insert(done,v)
			end
		end
		for _,v in pairs(setqueue) do
			v[1]:Set(v[2],v[3],v[4],v[5],true)
		end
	end
	-- Do liquid ticks
	for d,e in pairs(liquidticks) do
		local liquidticks2 = {}
		local breakable = {
			[6] = true,
			[50] = true,
			[51] = true,
		}

		for i,v in pairs(e) do
			liquidticks2[i] = v
		end
		liquidticks[d] = {}
		local done = {}
		for i,v in pairs(liquidticks2) do
			if not table.find(done,v[2]) then
				if v[1] > 0 then
					v[1] -= 1
					table.insert(liquidticks[d],v)
				else
					local cpos = v[2]
					local b0,c0 = getBlock(cpos.X,cpos.Y,cpos.Z,d)

					local dir = {
						Vector3.new(0,0,-1),
						Vector3.new(-1,0,0),
						Vector3.new(0,0,1),
						Vector3.new(1,0,0),
					}

					local prop = indexVector(c0.propdata,cpos.X%16,cpos.Y,cpos.Z%16)
					local level = prop and prop.level or 8

					local fpos = cpos + Vector3.new(0,-1,0)
					local b1,c1 = getBlock(fpos.X,fpos.Y,fpos.Z,d)

					local drain = true
					local high = 0

					---- Water
					if c0 and c0.loaded and waterid[b0] then
						local adjs = 0

						if b0 == 9 then 
							drain = false 
						else
							local pos = cpos
							local b,c = getBlock(pos.X,pos.Y + 1,pos.Z,d)
							if c and c.loaded and (b and waterid[b]) then
								drain = false
							else
								for i=1,4 do
									local pos = cpos + dir[i]
									local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
									if c and c.loaded and (b and waterid[b]) then
										local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
										local level2 = prop and prop.level or 8
										high = math.max(high,level2)
										if level2 > level then
											drain = false
										end
										if b == 9 then
											adjs += 1
										end
									end
								end
							end
						end

						if (not drain) and (level > 1) and b1 and (b1 ~= 0) and (((b0 == 9) and (b1 == 9)) or not fluidid[b1]) and (not breakable[b1]) then -- Horizontal flowing
							local w = {999,999,999,999}
							for i=1,4 do -- Check 4 directions
								local pos = cpos + dir[i]
								local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
								if c and c.loaded and not (b and (b ~= 0) and ((b == 9) or not fluidid[b]) and (not breakable[b])) then

									local open = {cpos + dir[i]}
									local closed = {}
									local found = false
									for j=1,5 do -- Iterate 5 times
										local nextopen = {}
										for _,v in pairs(open) do
											if not table.find(closed,v) then
												local b,c = getBlock(v.X,v.Y,v.Z,d)
												if c and c.loaded and not (b and (b ~= 0) and ((b == 9) or not fluidid[b]) and (not breakable[b])) then
													local b2,c2 = getBlock(v.X,v.Y - 1,v.Z,d)
													if c2 and c2.loaded and not (b2 and (b2 ~= 0) and (not fluidid[b2]) and (not breakable[b2])) then
														w[i] = j
														found = true
														break
													else
														for k=1,4 do -- Add to open table
															table.insert(nextopen,v + dir[k])
														end
													end
												end
												table.insert(closed,v)
											end
										end
										if found then break end
										open = nextopen
									end

								end
							end
							local lowest = 999
							local dirs = {}
							for i=1,4 do
								if w[i] == lowest then
									table.insert(dirs,i)
								elseif w[i] < lowest then
									dirs = {i}
									lowest = w[i]
								end
							end
							for _,a in pairs(dirs) do
								local pos = v[2] + dir[a]
								local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
								if c and c.loaded then
									if b and waterid[b] then
										local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
										local level2 = prop and prop.level or 8
										if level > (level2 + 1) then
											c:Set(pos.X%16,pos.Y,pos.Z%16,8,true,{
												level = level - 1
											})
										end
									elseif b and lavaid[b] then
										if b == 11 then -- Source block => Obsidian
											c1:Set(pos.X%16,pos.Y,pos.Z%16,49,true)
										else
											c1:Set(pos.X%16,pos.Y,pos.Z%16,4,true)
										end
										table.insert(upCh(c1).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.lava.extinguish})
									elseif b and breakable[b] then -- Breakable
										if b ~= 51 then
											local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),"item",c.Dimension)
											if iteme then
												iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
												iteme.Item = {
													Count = 1,
													id = b,
												}
												iteme.PickupDelay = 10
												iteme:Initialize()
											end
										end
										c:Set(pos.X%16,pos.Y,pos.Z%16,8,true,{
											level = level - 1
										})
									elseif not (b and (b ~= 0)) then
										c:Set(pos.X%16,pos.Y,pos.Z%16,8,true,{
											level = level - 1
										})
									end
								end
							end
						elseif b1 and (b1 == 8) then -- Fall flowing (Water)
							local prop = indexVector(c1.propdata,fpos.X%16,fpos.Y,fpos.Z%16)
							local level2 = prop and prop.level or 8
							if level2 < 8 then
								c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,8,true,{
									level = 8
								})
							end
						elseif b1 and lavaid[b1] then -- Fall flowing (Lava)
							if b1 == 11 then -- Source block => Obsidian
								c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,49,true)
							else
								c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,4,true)
							end
							--"extinguish2")

							table.insert(upCh(c1).events,{"sound",Vector3.new(fpos.X + .5,fpos.Y + .5,fpos.Z + .5),soundinfo.block.lava.extinguish})
						elseif b1 and breakable[b1] then -- Breakable
							if b1 ~= 51 then
								local iteme = createEntity(Vector3.new(fpos.X + .5,fpos.Y + .5,fpos.Z + .5),"item",c1.Dimension)
								if iteme then
									iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
									iteme.Item = {
										Count = 1,
										id = b1,
									}
									iteme.PickupDelay = 10
									iteme:Initialize()
								end
							end
							c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,8,true,{
								level = 8,
							})
						elseif not (b1 and (b1 ~= 0)) then -- Fall flowing
							c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,8,true,{
								level = 8,
							})
							for i=1,4 do
								local pos = fpos + dir[i]
								local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
								if c and c.loaded and (b and lavaid[b]) then
									if b == 11 then -- Source block => Obsidian
										c1:Set(pos.X%16,pos.Y,pos.Z%16,49,true)
									else
										c1:Set(pos.X%16,pos.Y,pos.Z%16,4,true)
									end
									--"extinguish3")

									table.insert(upCh(c1).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.lava.extinguish})
								end
							end
						end
						if adjs > 1 then
							c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,9,true)
						elseif drain then
							local draina = (high - level)
							if draina <= level then
								draina = 10
							end
							local newlevel = level - math.clamp(draina,1,2)
							if newlevel > 0 then
								c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,8,true,{
									level = newlevel
								})
							else
								c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,0,true)
							end
						end

						---- Lava
					elseif c0 and c0.loaded and lavaid[b0] then
						if b0 == 11 then 
							drain = false 
						else
							local pos = cpos
							local b,c = getBlock(pos.X,pos.Y + 1,pos.Z,d)
							if c and c.loaded and (b and lavaid[b]) then
								drain = false
							else
								for i=1,4 do
									local pos = cpos + dir[i]
									local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
									if c and c.loaded and (b and lavaid[b]) then
										local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
										local level2 = prop and prop.level or 8
										high = math.max(high,level2)
										if level2 > level then
											drain = false
										end
									end
								end
							end
						end

						if (not drain) and (level > 2) and b1 and (b1 ~= 0) and (((b0 == 11) and (b1 == 11)) or not fluidid[b1]) and (not breakable[b1]) then -- Horizontal flowing
							local w = {999,999,999,999}
							for i=1,4 do -- Check 4 directions
								local pos = cpos + dir[i]
								local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
								if c and c.loaded and not (b and (b ~= 0) and ((b == 11) or not fluidid[b]) and (not breakable[b])) then

									local open = {cpos + dir[i]}
									local closed = {}
									local found = false
									for j=1,4 do -- Iterate 4 times
										local nextopen = {}
										for _,v in pairs(open) do
											if not table.find(closed,v) then
												local b,c = getBlock(v.X,v.Y,v.Z,d)
												if c and c.loaded and not (b and (b ~= 0) and ((b == 11) or not fluidid[b]) and (not breakable[b])) then
													local b2,c2 = getBlock(v.X,v.Y - 1,v.Z,d)
													if c2 and c2.loaded and not (b2 and (b2 ~= 0) and (not fluidid[b2]) and (not breakable[b2])) then
														w[i] = j
														found = true
														break
													else
														for k=1,4 do -- Add to open table
															table.insert(nextopen,v + dir[k])
														end
													end
												end
												table.insert(closed,v)
											end
										end
										if found then break end
										open = nextopen
									end

								end
							end
							local lowest = 999
							local dirs = {}
							for i=1,4 do
								if w[i] == lowest then
									table.insert(dirs,i)
								elseif w[i] < lowest then
									dirs = {i}
									lowest = w[i]
								end
							end
							for _,a in pairs(dirs) do
								local pos = v[2] + dir[a]
								local b,c = getBlock(pos.X,pos.Y,pos.Z,d)
								if c and c.loaded then
									if b and lavaid[b] then
										local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
										local level2 = prop and prop.level or 8
										if level > (level2 + 2) then
											c:Set(pos.X%16,pos.Y,pos.Z%16,10,true,{
												level = level - 2
											})
										end
									elseif b and waterid[b] then
										--"yeaaa")

										c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,4,true) -- Turns itself into cobblestone
										table.insert(upCh(c0).events,{"sound",Vector3.new(cpos.X + .5,cpos.Y + .5,cpos.Z + .5),soundinfo.block.lava.extinguish})
									elseif b and breakable[b] then -- Breakable
										c:Set(pos.X%16,pos.Y,pos.Z%16,10,true,{
											level = level - 2
										})
										--"yez")

										table.insert(upCh(c).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.lava.extinguish})
									elseif not (b and (b ~= 0)) then
										local safe = true
										for i=1,4 do
											local spos = pos + dir[i]
											local b,c = getBlock(spos.X,spos.Y,spos.Z,d)
											if c and c.loaded and (b and waterid[b]) then
												safe = false
												c:Set(pos.X%16,pos.Y,pos.Z%16,4,true)
												--"extinguish4")

												table.insert(upCh(c).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.lava.extinguish})
												break
											end
										end
										if safe then
											c:Set(pos.X%16,pos.Y,pos.Z%16,10,true,{
												level = level - 2
											})
										end
									end
								end
							end
						elseif b1 and lavaid[b1] then -- Fall flowing (Into lava)
							local prop = indexVector(c1.propdata,fpos.X%16,fpos.Y,fpos.Z%16)
							local level2 = prop and prop.level or 8
							if level2 < 8 then
								c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,10,true,{
									level = 8
								})
							end
						elseif b1 and waterid[b1] then -- Fall flowing (Into water)
							c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,1,true)
							table.insert(upCh(c1).events,{"sound",Vector3.new(fpos.X + .5,fpos.Y + .5,fpos.Z + .5),soundinfo.block.lava.extinguish})
						elseif b1 and breakable[b1] then -- Breakable
							c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,10,true,{
								level = 8,
							})

							table.insert(upCh(c1).events,{"sound",Vector3.new(fpos.X + .5,fpos.Y + .5,fpos.Z + .5),soundinfo.block.lava.extinguish})
						elseif not (b1 and (b1 ~= 0)) then -- Fall flowing
							c1:Set(fpos.X%16,fpos.Y,fpos.Z%16,10,true,{
								level = 8,
							})
						end
						if drain then
							local draina = (high - level)
							if draina <= level then
								draina = 10
							end
							local newlevel = math.floor((level - math.clamp(draina,1,4))/2)*2
							if newlevel > 0 then
								c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,10,true,{
									level = newlevel
								})
							else
								c0:Set(cpos.X%16,cpos.Y,cpos.Z%16,0,true)
							end
						end
					end
				end

				table.insert(done,v[2])
			end
		end
	end

	debug.profileend()

	---- Tick entites

	debug.profilebegin("Ticking entities")

	local function generatePortal(x,y,z,d)
		for dy=0,4 do
			if (dy == 0) or (dy == 4) then
				for dx=0,3 do
					local x,y,z = x+dx,y+dy,z
					local ch = getChunk(math.floor(x/16),math.floor(z/16),d)
					if ch then ch:Set(x%16,y,z%16,49,true) end
				end
			else
				for dx=0,3 do
					local x,y,z = x+dx,y+dy,z
					local ch = getChunk(math.floor(x/16),math.floor(z/16),d)
					if ch then 
						if (dx == 0) or (dx == 3) then
							ch:Set(x%16,y,z%16,49,true)
						else
							ch:Set(x%16,y,z%16,90,true,{
								axis = "x"
							})
						end
					end
				end
			end
			if dy ~= 0 then
				for dx=0,3 do
					local x,y,z = x+dx,y+dy,z+1
					local ch = getChunk(math.floor(x/16),math.floor(z/16),d)
					if ch then ch:Set(x%16,y,z%16,0,true) end

					local x,y,z = x+dx,y+dy,z-1
					local ch = getChunk(math.floor(x/16),math.floor(z/16),d)
					if ch then ch:Set(x%16,y,z%16,0,true) end
				end
			end
		end
	end

	local function attemptTeleport(ent,c,d)
		if ent.PortalCooldown and (ent.PortalCooldown > 0) then return end
		if d == "overworld" then
			local cx,cz = math.floor(ent.Pos.X/8/16),math.floor(ent.Pos.Z/8/16)
			local chunk = getChunk(cx,cz,"nether")
			if not (chunk and chunk.loaded) then
				if getTicket(cx,cz,"nether") > 31 then
					addTicket(cx,cz,30,"nether",{
						Expire = 300
					})
				end
			else
				local found = false
				for dx=-1,1 do
					for dz=-1,1 do
						local chunk = getChunk(cx + dx,cz + dz,"nether")
						if chunk and chunk.loaded and chunk.blockdata then
							for x=0,15 do
								for z=0,15 do
									for y=127,0,-1 do
										if indexVector(chunk.blockdata,x,y,z) == 90 then
											if indexVector(chunk.blockdata,x,y - 1,z) == 49 then
												ent.Pos = Vector3.new((cx + dx)*16 + x + .5,y + .1,(cz + dz)*16 + z + .5)
												spawn(function() 
													for i = 1,5 do -- character might position itself to the old position, leading to lava or outside the chunk
														ent.FallDistance = 0
														ent.Pos = Vector3.new((cx + dx)*16 + x + .5,y + .1,(cz + dz)*16 + z + .5)
														--ent.Health = 20
														wait()
													end
												end)
												ent.PortalCooldown = 300
												ent.FallDistance = 0
												if c then
													table.remove(c.entitydata,table.find(c.entitydata,ent))
													table.insert(chunk.entitydata,ent)
												else
													ent.changeMotion = true
													ent.Dimension = "nether"
												end
												found = true
												break
											end
										end
									end
									if found then break end
								end
								if found then break end
							end
						end
						if found then break end
					end
					if found then break end
				end
				if not found then
					local pos = ent.Pos
					generatePortal(math.floor(ent.Pos.X/8),70,math.floor(ent.Pos.Z/8),"nether")
					--ent.Pos = Vector3.new(math.floor(pos.X/8),70,math.floor(pos.Z/8))

				end
			end
		elseif d == "nether" then
			local cx,cz = math.floor(ent.Pos.X*8/16),math.floor(ent.Pos.Z*8/16)
			local chunk = getChunk(cx,cz,"overworld")
			if not (chunk and chunk.loaded) then
				if getTicket(cx,cz,"overworld") > 31 then
					addTicket(cx,cz,30,"overworld",{
						Expire = 30
					})
				end
			else
				local found = false
				for dx=-1,1 do
					for dz=-1,1 do
						local chunk = getChunk(cx + dx,cz + dz,"overworld")
						if chunk and chunk.loaded and chunk.blockdata then
							for x=0,15 do
								for z=0,15 do
									for y=127,0,-1 do
										if indexVector(chunk.blockdata,x,y,z) == 90 then
											if indexVector(chunk.blockdata,x,y - 1,z) == 49 then
												ent.Pos = Vector3.new((cx + dx)*16 + x + .5,y + .1,(cz + dz)*16 + z + .5)
												spawn(function() 
													for i = 1,5 do
														ent.Pos = Vector3.new((cx + dx)*16 + x + .5,y + .1,(cz + dz)*16 + z + .5)
														--ent.Health = 20
														ent.FallDistance = 0

														wait()
													end
												end)
												ent.PortalCooldown = 300
												ent.FallDistance = 0
												if c then
													table.remove(c.entitydata,table.find(c.entitydata,ent))
													table.insert(chunk.entitydata,ent)
												else
													ent.changeMotion = true
													ent.Dimension = "overworld"
												end
												found = true
												break
											end
										end
									end
									if found then break end
								end
								if found then break end
							end
						end
					end
				end
				if not found then
					local pos = ent.Pos
					generatePortal(math.floor(ent.Pos.X*8),getHM(math.floor(ent.Pos.X*8),math.floor(ent.Pos.Z*8)),math.floor(ent.Pos.Z*8),"overworld")
					ent.Pos = Vector3.new(math.floor(ent.Pos.X*8),getHM(math.floor(ent.Pos.X*8),math.floor(ent.Pos.Z*8)),math.floor(ent.Pos.Z*8))

				end
			end
		end
	end

	local removeEnts = {}
	lastEntities = {}

	local radpos = {}
	for p,v in pairs(playerinfo) do
		if p.Parent == game.Players then
			table.insert(radpos,v.Pos)
		end
	end

	for _,c in pairs(tickLC) do
		for _,v in pairs(c.entitydata) do
			local dmginfo = dmgreq[v.UUID]
			if dmginfo then
				v:Damage(world,dmginfo[1],dmginfo[2],dmginfo[3],dmginfo[4])
				dmgreq[v.UUID] = nil
			end

			----"Ticked",v.id,v.Pos)
			v:GlobalTick(world,TPS,c.Dimension)
			v:Tick(world,TPS,c.Dimension)
			v:AfterTick(world,TPS,c.Dimension)

			local removing = false
			if v.Decay then
				v.Decay = v.Decay - 1
				if v.Decay <= 0 then
					removing = true
					table.insert(removeEnts,{c.entitydata,v})
					--table.remove(c.entitydata,table.find(c.entitydata,v))
				end
			elseif v.Health and (v.Health <= 0) then
				v:OnDeath(world,c.Dimension)
				v.Decay = 20
			elseif v.inPortal then
				attemptTeleport(v,c,c.Dimension)
			end

			if v.id == "creeper" then
				local persist = false
				for _,vp in pairs(radpos) do
					if (vp - v.Pos).Magnitude < 44 then
						persist = true
						break
					end
				end
				if not persist then
					v.Decay = 0
					removing = true
					table.insert(removeEnts,{c.entitydata,v})
				end
			end
			if v.id == "creeper" then
				local persist = false
				for _,vp in pairs(radpos) do
					if (vp - v.Pos).Magnitude < 44 then
						persist = true
						break
					end
				end
				if not persist then
					v.Decay = 0
					removing = true
					table.insert(removeEnts,{c.entitydata,v})
				end
			end
			if not removing then
				entchunks[v] = c

				table.insert(updatedEnt[c.Dimension],v)
				table.insert(lastEntities,v)
			end
		end
	end

	for _,v in pairs(removeEnts) do
		table.remove(v[1],table.find(v[1],v[2]))
	end

	debug.profilebegin("Ticking players")

	for p,v in pairs(playerinfo) do
		if p.Parent == game.Players then
			local dmginfo = dmgreq[p]
			if dmginfo then
				v:Damage(world,dmginfo[1],dmginfo[2],dmginfo[3],dmginfo[4])
				dmgreq[p] = nil
			end

			v:GlobalTick(world,TPS,v.Dimension)
			v:Tick(world,TPS,v.Dimension)
			v:AfterTick(world,TPS,v.Dimension)

			if v.Decay and (v.Decay > 0) then
				v.Decay = v.Decay - 1
				if v.Decay == 0 then
					playerinfo[p] = nil
				end
			elseif v.Health and (v.Health <= 0) then
				v.Decay = 20
				for inum,slot in pairs(v.Inventory) do
					local count = slot.Count
					local id = slot.id
					local count2 = slot.Count or 0
					if id and (count2 > 0) then
						local pos = Vector3.new(v.Pos.X,v.Pos.Y + 1.5,v.Pos.Z)
						local cx,cy = math.floor(pos.X/16),math.floor(pos.Z/16)
						local c = world.getChunk(cx,cy,v.Dimension)

						if c and c.loaded then
							local dropping = math.min(count,idinfo[id] and idinfo[id].Stack or 64)

							local iteme = createEntity(Vector3.new(v.Pos.X,v.Pos.Y + .8,v.Pos.Z),"item",v.Dimension)
							if iteme then
								iteme.Motion = CFrame.fromEulerAnglesYXZ(0.15,math.pi*2*math.random(),0).LookVector*(0.05 + math.random()*.15)
								iteme.Item = {
									Count = dropping,
									id = id,
									tag = slot.tag
								}
								iteme.PickupDelay = 10
								iteme:Initialize()
							end
						end
					end
				end
				v.Inventory = {}

				v.updateInventory = true
			elseif v.inPortal then
				attemptTeleport(v,nil,v.Dimension)
			end
		end
	end

	debug.profilebegin("UpdateEntities")
	for d,e in pairs(updatedEnt) do
		for _,v in pairs(e) do
			local cch = entchunks[v]
			local cx,cy = math.floor(v.Pos.X/16),math.floor(v.Pos.Z/16)
			local new = v.NextPos or v.Pos
			local ncx,ncy = math.floor(new.X/16),math.floor(new.Z/16)
			if not ((ncx == cx) and (ncy == cy)) then
				local newc = getChunk(ncx,ncy,d)

				if newc and newc.entitydata then
					local ed = cch and cch.entitydata 
					local exist = ed and table.find(ed,v)
					if exist then
						table.remove(ed,exist)
					end

					table.insert(newc.entitydata,v)

					v.Pos = v.NextPos or v.Pos
					v.NextPos = nil

					cch = newc
				else
					v.NextPos = nil
				end
			else
				v.Pos = v.NextPos or v.Pos
				v.NextPos = nil
			end
			local update = {
				-- IDs
				id = v.id,
				UUID = v.UUID,

				-- Physics
				Pos = {v.Pos.X,v.Pos.Y,v.Pos.Z},
				Motion = {v.Motion.X,v.Motion.Y,v.Motion.Z},
				Rotation = {v.Rotation.X,v.Rotation.Y},

				Size = {v.Size.X,v.Size.Y},

				OnGround = v.OnGround,

				-- Health
				Health = v.Health,

				-- Ticks
				Fire = v.Fire,

				-- Other
				BlockState = v.BlockState,
				Item = v.Item,
				Fuse = v.Fuse,
			}

			table.insert(upCh(cch).entitydata,update)
		end
	end

	updatedEnt.overworld = {}
	updatedEnt.nether = {}
	entchunks = {}
	debug.profileend()

	---- Turn block sets into updates

	for d,e in pairs(blocksets) do 
		local removal = {}
		for _,v in ipairs(e) do
			local pos = v[1]
			local id = v[2]
			local prop = v[3]
			local c = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)
			if c then
				table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),id,prop})
			end
			table.insert(removal,v)
		end
		for _,v in pairs(removal) do
			table.remove(blocksets[d],table.find(blocksets[d],v))
		end
	end

	---- Turn tile entities sets into updates

	for d,e in pairs(tileentsets) do
		local removal = {}
		for _,v in ipairs(e) do
			local x,y,z = v[1],v[2],v[3]
			local dat = v[4]

			local c = getChunk(math.floor(x/16),math.floor(z/16),d)
			if c then
				table.insert(upCh(c).tileentities,{Vector3.new(x,y,z),dat})
			end
			table.insert(removal,v)
		end
		for _,v in pairs(removal) do
			table.remove(tileentsets[d],table.find(tileentsets[d],v))
		end
	end

	---- Sort events

	for d,e in pairs(pendingEvents) do
		for _,v in pairs(e) do
			if v[1] == "collect" then
				local pos = v[2]
				local c = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)
				if c and c.loaded then
					table.insert(upCh(c).events,{"collect",v[3],v[4],v[5]}) -- "collect",pos,collected,collector,count => "collect",collected,collector,count
				end
			elseif v[1] == "sound" then
				local pos = v[2]
				local c = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)
				if c and c.loaded then
					table.insert(upCh(c).events,{"sound",v[2],v[3],v[4]})
				end
			elseif v[1] == "anim" then
				local pos = v[2].Pos
				local c = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)
				if c and c.loaded then
					table.insert(upCh(c).events,{"anim",v[2].UUID or v[2].Player,v[3]})
				end
			elseif v[1] == "explosion" then
				local pos = v[2]
				local c = getChunk(math.floor(pos.X/16),math.floor(pos.Z/16),d)
				if c and c.loaded then
					table.insert(upCh(c).events,{"explosion",v[2]})
				end
			elseif v[1] == "damage" then
				--	playerinfo[v[2]].Health = playerinfo[v[2]].Health - 1
			end

		end
	end

	---- Send updates

	debug.profilebegin("Send updates")

	debug.profilebegin("Putting stuff in updates")
	--local pr = false
	local pupdates = {}

	local plchunks = {
		overworld = {},
		nether = {}
	}

	for p,v in pairs(playerinfo) do
		local x,y = math.floor(v.Pos.X/16),math.floor(v.Pos.Z/16)
		plchunks[v.Dimension][x] = plchunks[v.Dimension][x] or {}
		plchunks[v.Dimension][x][y] = plchunks[v.Dimension][x][y] or {}
		local ents = {
			-- Player
			Player = v.Player,

			-- Physics
			Pos = {v.Pos.X,v.Pos.Y,v.Pos.Z},
			Motion = {v.Motion.X,v.Motion.Y,v.Motion.Z},
			Rotation = {v.Rotation.X,v.Rotation.Y},

			AddMotion = v.AddMotion and {v.AddMotion.X,v.AddMotion.Y,v.AddMotion.Z},

			Size = {v.Size.X,v.Size.Y},

			OnGround = v.OnGround,

			-- Health
			Health = v.Health,
			Decay = v.Decay,

			-- Ticks
			Fire = v.Fire,

			-- Misc
			Dimension = v.Dimension,
			Inventory = v.Inventory,
			SelectedItem = v.SelectedItem
		}

		table.insert(plchunks[v.Dimension][x][y],ents)
		local ch = getChunk(x,y,v.Dimension)
		if ch then upCh(ch) end
	end

	debug.profileend()

	for i,v in pairs(updates) do
		for p,e in pairs(playerinfo) do
			if i.Dimension == e.Dimension then
				local pos = e.Pos
				local cpos = Vector2.new(pos.X/16,pos.Z/16)
				local distv = cpos - Vector2.new(i.xPos,i.zPos)
				local dist = math.max(math.abs(distv.X),math.abs(distv.Y))
				if dist <= viewdistance then
					pupdates[p] = pupdates[p] or {
						chunks = {},
						players = {},

						changeMotion = e.changeMotion,
						updateInventory = e.updateInventory
					}
					table.insert(pupdates[p].chunks,{i.xPos,i.zPos,v})
					if plchunks[e.Dimension][i.xPos] and plchunks[e.Dimension][i.xPos][i.zPos] then
						for _,pe in pairs(plchunks[e.Dimension][i.xPos][i.zPos]) do
							table.insert(pupdates[p].players,pe)
						end
					end
				end
			end
		end
	end

	debug.profileend()

	debug.profilebegin("Actually sending updates")

	for p,v in pairs(pupdates) do

		game.ReplicatedStorage.UpdateWorld:FireClient(p,v)
	end

	debug.profileend()

	pendingEvents.overworld = {}
	pendingEvents.nether = {}

	debug.profileend()

	---- Misc

	--	local total = 0
	--	for _,v in pairs(overworld) do
	--		for _,v2 in pairs(v) do
	--			total = total + 1
	--		end
	--	end
	--	--"Loaded chunks:",#loadedChunks.overworld,"out of",total)


end

--[Connections]

game.ReplicatedStorage.LoadChunk.OnServerInvoke = function(plr,cx,cy,d)
	local info = playerinfo[plr]
	d = d or "overworld"

	if info and (info.Dimension == d) then
		local pos = info.Pos
		local cpos = Vector2.new(pos.X/16,pos.Z/16)
		local distv = cpos - Vector2.new(cx,cy)
		local dist = math.max(math.abs(distv.X),math.abs(distv.Y))

		if dist <= viewdistance then
			local level = getTicket(cx,cy,d)

			if level < 34 then
				local chunk = getChunk(cx,cy,d)

				if chunk then
					if not chunk.generating then
						local data = chunk.compressed or compressChunk(chunk)

						return data
					end
				end
			end
		end
	end
end
local world1 = nil
local updates1 = {}
game.ReplicatedStorage.SendState.OnServerInvoke = function(plr,info,start)
	if type(info) == "table" then
		statequery[plr] = statequery[plr] or {
			query = {},
			free = 	math.huge
		}

		local errblock = info.ibreak and info.targetBlock or info.iplace and (info.targetBlock + info.targetBlockNor)
		----plr,statequery[plr].free)

		if statequery[plr].free <= 0 then 
			local pinfo = playerinfo[plr]
			return false,errblock and getBlock(errblock.X,errblock.Y,errblock.Z,pinfo and pinfo.Dimension),0
		end

		local state = {}

		-- Inventory
		state.slotselect = info.slotselect

		state.openblock = info.openblock

		-- Targeting
		state.targetBlock = info.targetBlock
		state.targetBlockNor = info.targetBlockNor
		state.targetFluid = info.targetFluid
		state.targetEntity = info.targetEntity
		state.plrname = plr.Name
		-- Action
		state.iattack = info.iattack
		state.ibreak = info.ibreak
		state.iplace = info.iplace
		state.ibroken = info.ibroken
		state.iuse = info.iuse
		state.iinteract = info.iinteract
		state.ieat = info.ieat
		state.ieaten = info.ieaten

		state.idrop = info.idrop
		state.icraft = info.icraft

		state.imove = info.imove
		state.itransfer = info.itransfer

		state.iswing = info.iswing

		-- Physics
		state.motion = info.motion
		state.rotation = info.rotation
		state.pos = info.pos
		state.onGround = info.onGround

		-- Final

		state.ticksPlaced = ticks

		local inf = playerinfo[plr]
     
		if inf and inf.Health > 0 then
			if workspace.WorldDebug.Insntant.Value == false then
			table.insert(statequery[plr].query,state)
			else
				local function upCh(c)
					updates[c] = updates[c] or {
						blockdata = {},
						tileentities = {},
						entitydata = {},
						events = {}
					}
					return updates[c]
				end
				local function breakBlock(plr,inf,b,c,pos,harvest)
					local prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
					c:Set(pos.X%16,pos.Y,pos.Z%16,0,true)
					table.insert(upCh(c).events,{"sound",Vector3.new(pos.X + .5,pos.Y,pos.Z + .5),soundinfo.block[idinfo[b].sound]["break"],plr})

					if harvest and (inf.gamemode ~= 1) then	
						if b == 119 or b == 56 or b == 15 or b == 16 and workspace.WorldDebug.XP.Value == true then -- put you ore here to drop xp
							game.ReplicatedStorage.SpawnEntityRQ:Fire(Vector3.new(pos.X + .5,pos.Y - 1.5,pos.Z + .5),"xp",playerinfo[plr])
						end
						if b == 345 then
							setBlock(pos.X,pos.Y,pos.Z,9)
						end
						if b ~= 345 then
							dropBlock(b,c,pos,prop)
						end
					end
				end

				local function dropSlot(plr,inf,slotid,count)
					count = count or 64
					local slot,inum = getSlot(inf.Inventory,slotid)
					if slot and slot.Count then
						count = math.min(count,slot.Count)
						local id = slot.id
						local count2 = slot.Count or 0
						if id and (count2 > 0) then
							local pos = Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z)
							local cx,cy = math.floor(pos.X/16),math.floor(pos.Z/16)
							local c = getChunk(cx,cy,inf.Dimension)

							if c and c.loaded then
								local dropping = math.min(count,idinfo[id] and idinfo[id].Stack or 64)

								local iteme = createEntity(Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z),"item",inf.Dimension)
								if iteme then
									iteme.Motion = CFrame.fromEulerAnglesYXZ(inf.Rotation.Y,inf.Rotation.X,0).LookVector*0.5
									iteme.Item = {
										Count = dropping,
										id = id,
										tag = slot.tag
									}
									iteme.PickupDelay = 40
									iteme:Initialize()
								end

								slot.Count -= dropping
								if slot.Count <= 0 then
									table.remove(inf.Inventory,inum)
								end

								inf.updateInventory = true
							end
						end
					end
				end

				local function craftResult(plr,inf,openblock)
					local inventory = inf.Inventory

					local tab = {}

					local blockid = openblock and getBlock(openblock.X,openblock.Y,openblock.Z,inf.Dimension)

					if blockid and (blockid == 58) then

						local slot80 = getSlotContent(getSlot(inventory,80))
						local slot81 = getSlotContent(getSlot(inventory,81))
						local slot82 = getSlotContent(getSlot(inventory,82))
						local slot83 = getSlotContent(getSlot(inventory,83))
						local slot84 = getSlotContent(getSlot(inventory,84))
						local slot85 = getSlotContent(getSlot(inventory,85))
						local slot86 = getSlotContent(getSlot(inventory,86))
						local slot87 = getSlotContent(getSlot(inventory,87))
						local slot88 = getSlotContent(getSlot(inventory,88))

						for i=1,2 do
							if not (slot80[2] or slot83[2] or slot86[2]) then
								slot80 = slot81
								slot81 = slot82
								slot82 = {0}

								slot83 = slot84
								slot84 = slot85
								slot85 = {0}

								slot86 = slot87
								slot87 = slot88
								slot88 = {0}
							else
								break
							end
						end

						for i=1,2 do
							if not (slot80[2] or slot81[2] or slot82[2]) then
								slot80 = slot83
								slot83 = slot86
								slot86 = {0}

								slot81 = slot84
								slot84 = slot87
								slot87 = {0}

								slot82 = slot85
								slot85 = slot88
								slot88 = {0}
							else
								break
							end
						end

						tab = {
							slot80,slot81,slot82,
							slot83,slot84,slot85,
							slot86,slot87,slot88
						}

					else

						local slot80 = getSlotContent(getSlot(inventory,80))
						local slot81 = getSlotContent(getSlot(inventory,81))
						local slot82 = getSlotContent(getSlot(inventory,82))
						local slot83 = getSlotContent(getSlot(inventory,83))

						if not (slot80[2] or slot82[2]) then
							slot80 = slot81
							slot82 = slot83
							slot81 = {0}
							slot83 = {0}
						end

						if not (slot80[2] or slot81[2]) then
							slot80 = slot82
							slot81 = slot83
							slot82 = {0}
							slot83 = {0}
						end

						tab = {
							slot80,slot81,{0},
							slot82,slot83,{0},
							{0},{0},{0}
						}
					end

					local result = {0,0}
					for v,i in pairs(recipes[1]) do
						local correct = true
						for a=1,9 do
							local actual = tab[a]
							if not actual[2] then
								actual[2] = nil -- Lua as always.
							end
							if actual[2] ~= v[a] then
								correct = false
							end
						end
						if correct then
							result = {i,v[10] or 1}
							break
						end
					end

					local function consume(i)
						local slot = getSlot(inventory,i)
						local count = slot and slot.Count
						local id = slot and slot.id
						if slot and count and (count > 0) and id and (id ~= 0) then
							slot.Count -= 1
						end
					end

					if result[1] ~= 0 then
						local handslot = getSlot(inventory,-1)
						local hsc = getSlotContent(handslot)
						if not hsc[2] then
							for i=80,88 do consume(i) end
							setSlot(inventory,-1,{
								id = result[1],
								Count = result[2]
							})
						elseif hsc[2] == result[1] then
							if hsc[1] + result[2] <= (idinfo[result[1]].Stack or 64) then
								for i=80,88 do consume(i) end
								handslot.Count = hsc[1]+result[2]
							end
						end
					end

					--inf.updateInventory = true

				end
				
               local i = plr
				local ok,msg = pcall(function()

					local inf = playerinfo[i]
					local alive = inf.Health and (inf.Health > 0)

					inf.SelectedItemSlot = math.clamp(state.slotselect or inf.SelectedItemSlot or 0,0,8)

					local selslot,selnum = getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
					local selid = selslot and selslot.id
					local selcount = selslot and selslot.Count or 0

					-- Actions
					if state.icraft then
						craftResult(i,inf,state.openblock)
						inf.updateInventory = true
					end

					if state.imove then
						for _,m in ipairs(state.imove) do
							local transfer = m[1]
							local slot1,slot2 = m[2],m[3]
							local islot = getSlot(inf.Inventory,slot1)
							local count = m[4]

							local st
							local ast
							local ch,te,teid,dir
							local allowed = true
							if transfer == 0 then
								st = inf.Inventory
								ast = inf.Inventory
							else
								local iext
								local ext = state.itransfer
								ch = getChunk(math.floor(ext.X/16),math.floor(ext.Z/16),inf.Dimension)
								if ch and ch.loaded then
									te = ch:GetTileEntity(ext.X%16,ext.Y,ext.Z%16)
									if te then
										iext = te.Items
										teid = te.id
									end
								end
								if iext then
									if transfer == 1 then
										st = inf.Inventory
										ast = iext
										dir = 2
									elseif transfer == 2 then
										st = iext
										ast = inf.Inventory
										dir = 1
									elseif transfer == 3 then
										st = iext
										ast = iext
										dir = 3
									end
								else
									st = inf.Inventory
									ast = inf.Inventory
								end
							end
							if teid and (dir > 0) then
								-- External Inventory; Blocks
								if teid == 54 then -- Chest
									if (dir == 1) or (dir == 3) then
										if (slot1 >= 27) or (slot1 < 0) then
											allowed = false
										end
									end
									if (dir == 2) or (dir == 3) then
										if (slot2 >= 27) or (slot2 < 0) then
											allowed = false
										end
									end
								elseif teid == 61 then -- Furnace
									if dir == 3 then
										allowed = false -- No.
									else
										if (dir == 2) then -- Supply
											if slot2 == 2 then
												allowed = false
											elseif slot2 == 1 then
												if islot and not smeltrecipes[2][islot.id] then -- Not a fuel
													allowed = false
												end
											elseif slot2 == 0 then
												allowed = true
											else
												allowed = false
											end
										end
									end
								end
							else
								-- Internal Inventory
								if slot2 == -1 then
									allowed = true
								elseif (slot2 >= 100) and (slot2 <= 103) then -- Armor Slots
									allowed = false

									local armor
									local atype

									if islot and islot.id then
										local info = idinfo[islot.id]
										armor = info.armor
										atype = info.type
									end

									if slot2 == 103 then -- Helmet
										if armor and (atype == "helmet") then
											allowed = true
										end
									elseif slot2 == 102 then -- Chestplate
										if armor and (atype == "chestplate") then
											allowed = true
										end
									elseif slot2 == 101 then -- Leggings
										if armor and (atype == "leggings") then
											allowed = true
										end
									elseif slot2 == 100 then -- Boots
										if armor and (atype == "boots") then
											allowed = true
										end
									end
								elseif not ( ((slot2 >= 0) and (slot2 <= 35)) or ((slot2 >= 80) and (slot2 <= 88)) ) then -- Other
									allowed = false
								end
							end
							if allowed then
								moveSlot(st, slot1, ast, slot2, count)
								if ch and te then
									table.insert(tileentsets[inf.Dimension],{te.x,te.y,te.z,te})
								end
							end
						end
						--inf.updateInventory = true
					end

					if state.idrop then
						for _,d in pairs(state.idrop) do
							dropSlot(i,inf,d[1],d[2])
						end
						inf.updateInventory = true
						game.ReplicatedStorage.Update:FireClient(plr,"RenderInventory")
					end

					if alive and state.iattack then

						local dmg = 1
						local tdmg

						if selid and (selcount > 0) then
							local inf = idinfo[selid] 

							local dmgtypes = {
								sword = {
									wood = 5,
									gold = 5,
									stone = 6,
									iron = 7,
									diamond = 8
								},
								axe = {
									wood = 4,
									gold = 4,
									stone = 5,
									iron = 6,
									diamond = 7
								},
								shovel = {
									wood = 2,
									gold = 2,
									stone = 3,
									iron = 4,
									diamond = 5
								},
								pickaxe = {
									wood = 3,
									gold = 3,
									stone = 4,
									iron = 5,
									diamond = 6,
								}
							}

							dmg = dmgtypes[inf.type] and dmgtypes[inf.type][inf.material] or 1

							if inf.type == "sword" then
								tdmg = 1
							elseif (inf.type == "pickaxe") or (inf.type == "shovel") or (inf.type == "axe") then
								tdmg = 2
							end
						end

						local id = state.targetEntity
						local plr = id and game.Players:FindFirstChild(id)
						if plr then
							local inf2 = playerinfo[plr]
							if inf2 and (inf2.Dimension == inf.Dimension)  and ((inf2.Pos - inf.Pos).Magnitude < 8) and workspace.WorldDebug.DisablePVP.Value == false then
								inf2:Damage(world,"generic",dmg,playerinfo[i])
								if inf2.Health == 0 and not plr.Character:FindFirstChild("Dead") then
									Instance.new("BoolValue",plr.Character).Name = "Dead"
									local data = {
										Message = tostring(inf2.Player.Name.." was slain by "..inf.Player.Name),
										Name = "Server",
										Color = Color3.fromRGB(252, 216, 10),
										MessageColor = Color3.fromRGB(252, 216, 10)
									}

									game.ReplicatedStorage.ServerMessage:FireAllClients(i,data,true)
								end
								if tdmg then
									if not selslot.tag then
										selslot.tag = {}
									end
									selslot.tag.Damage = (selslot.tag.Damage or 0) + tdmg
									if selslot.tag.Damage >= idinfo[selid].durability then
										selslot.tag.Damage = 0
										selslot.Count -= 1
										if selslot.Count <= 0 then
											local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
											if c and c.loaded then
												table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
											end
											table.remove(inf.Inventory,selnum)
											inf.updateInventory = true
										end
									end
								end
							end
						elseif id then
							for _,v in pairs(getNearbyEntities(playerinfo[i].Pos,inf.Dimension)) do
								if v.UUID == id then
									if ((v.Pos - inf.Pos).Magnitude < 8) then
										v:Damage(world,"generic",dmg,playerinfo[i])

										if tdmg then
											if not selslot.tag then
												selslot.tag = {}
											end
											selslot.tag.Damage = (selslot.tag.Damage or 0) + tdmg
											if selslot.tag.Damage >= idinfo[selid].durability then
												selslot.tag.Damage = 0
												selslot.Count -= 1
												if selslot.Count <= 0 then
													local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
													if c and c.loaded then
														table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
													end
													table.remove(inf.Inventory,selnum)
													inf.updateInventory = true
												end
											end
										end
									end
									break
								end
							end
						end

					elseif state.iplace then
						inf.updateInventory = true
						game.ReplicatedStorage.Update:FireClient(plr,"RenderInventory")
						local pos1 = state.targetBlock
						local nor = state.targetBlockNor
						local pos2 = pos1 + nor
						local b1,c1 = getBlock(pos1.X,pos1.Y,pos1.Z,inf.Dimension)
						local b2,c2 = getBlock(pos2.X,pos2.Y,pos2.Z,inf.Dimension)

						local dist = (pos2 - inf.Pos).Magnitude

						local allowed = true
						local prop
						local aid = selid
						if b2 and (b2 ~= 0) and not fluidid[b2] then
							allowed = false
						elseif selid == 6 then
							allowed = false
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if g and ((g == 2) or (g == 3)) then
								allowed = true
							end
						elseif selid == 50 then -- Torch
							allowed = false
							if b1 and isSolid(b1) then
								if nor == Vector3.new(0,1,0) then
									allowed = true
								elseif nor == Vector3.new(1,0,0) then
									allowed = true
									prop = {facing = "east"}
								elseif nor == Vector3.new(-1,0,0) then
									allowed = true
									prop = {facing = "west"}
								elseif nor == Vector3.new(0,0,-1) then
									allowed = true
									prop = {facing = "north"}
								elseif nor == Vector3.new(0,0,1) then
									allowed = true
									prop = {facing = "south"}
								end
							end
						elseif (selid == 53) or (selid == 67) then -- Stairs
							local rot = inf.Rotation.X
							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north
								prop = {facing = "north"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west
								prop = {facing = "west"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south
								prop = {facing = "south"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east
								prop = {facing = "east"}
							end
						elseif (selid == 61) or (selid == 54) or (selid == 175)  then -- Rotating blocks (No up & down facing)
							local rot = inf.Rotation.X

							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
								prop = {facing = "south"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
								prop = {facing = "east"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
								prop = {facing = "north"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
								prop = {facing = "west"}
							end

							--]]
						elseif (selid == 69696)  then -- bed
							local rot = inf.Rotation.X

							if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
								prop = {facing = "south"}
							elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
								prop = {facing = "east"}
							elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
								prop = {facing = "north"}
							elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
								prop = {facing = "west"}
							end
							--
							if prop.facing then
								local facingDirection = prop.facing

								local newPos = {X = pos2.X, Y = pos2.Y, Z = pos2.Z}
								local bed2tested = false
								if bed2tested then
									if facingDirection == "south" then
										newPos.Z = newPos.Z - 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.Z = newPos.Z + 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "east" then
										newPos.X = newPos.X - 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.X = newPos.X + 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "north" then
										newPos.Z = newPos.Z + 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.Z = newPos.Z - 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									elseif facingDirection == "west" then
										newPos.X = newPos.X + 1
										local g1 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g1 and g1 ~= 0 then
											allowed = false
										end

										newPos.X = newPos.X - 1
										local g2 = getBlock(newPos.X, newPos.Y, newPos.Z, inf.Dimension)
										if g2 and g2 ~= 0 then
											allowed = false
										end
										if allowed then

										end
									end
								end



								allowed = true


							end
							--]]

						elseif (selid == 259) then -- Flint and Steel
							aid = 51

							prop = {age = 0}

							local t = b1
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if t and (t == 46) then
								allowed = true
							elseif t and (t ~= 0) and idinfo[t].fire then
								allowed = true
							elseif g and (g ~= 0) and (g ~= 51) then
								allowed = true
							end
						elseif (selid == 295) then -- Wheat Seeds
							aid = 59
							allowed = false
							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							if g and (g == 60) then
								allowed = true
							end
						elseif (selid == 324) or (selid == 330) or (selid == 489)  then
							allowed = false

							if selid == 324 then
								aid = 64
							elseif selid == 330 then
								aid = 71
							elseif selid == 489 then
								aid = 489
							end

							local g = getBlock(pos2.X,pos2.Y-1,pos2.Z,inf.Dimension)
							local t = getBlock(pos2.X,pos2.Y+1,pos2.Z,inf.Dimension)
							if g and isSolid(g) and not (t and (t ~= 0)) then
								allowed = true

								local dir = 2

								local rot = inf.Rotation.X
								if (rot >= (-math.pi/4)) and (rot <= (math.pi/4)) then -- Facing north => South
									dir = 0
									prop = {facing = "south"}
								elseif (rot >= (math.pi/4)) and (rot <= (3*math.pi/4)) then -- Facing west => East
									dir = 1
									prop = {facing = "east"}
								elseif (rot >= (3*math.pi/4)) or (rot <= (-3*math.pi/4)) then -- Facing south => North
									prop = {facing = "north"}
								elseif (rot >= (-3*math.pi/4)) and (rot <= (-math.pi/4)) then -- Facing east => West
									dir = 3
									prop = {facing = "west"}
								end

								prop.half = "lower"

								local hinge = "left"
								if dir == 0 then
									local n = getBlock(pos2.X-1,pos2.Y,pos2.Z,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 1 then
									local n = getBlock(pos2.X,pos2.Y,pos2.Z+1,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 2 then
									local n = getBlock(pos2.X+1,pos2.Y,pos2.Z,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								elseif dir == 3 then
									local n = getBlock(pos2.X,pos2.Y,pos2.Z-1,inf.Dimension)
									if n and (n == aid) then
										hinge = "right"
									end
								end

								prop.hinge = hinge
							end
						elseif (selid == 326) then -- Water Bucket
							aid = 9
						elseif (selid == 327) then -- Lava Bucket
							aid = 11
						end

						if allowed and alive and (dist < 10) and aid and idinfo[aid].block and (selcount > 0) and c1 and c1.loaded and c2 and c2.loaded then

							if inf.gamemode ~= 1 then
								inf.updateInventory = true
								if (selid == 326) or (selid == 327)  then
									selslot.id = 325
								elseif (selid == 259) then
									if not selslot.tag then
										selslot.tag = {}
									end
									selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
									if selslot.tag.Damage >= idinfo[selid].durability then
										selslot.tag.Damage = 0
										selslot.Count -= 1
										if selslot.Count <= 0 then
											local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
											if c and c.loaded then
												table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
											end
											table.remove(inf.Inventory,selnum)
											inf.updateInventory = true
										end
									end
								else
									selslot.Count = selslot.Count - 1
									if selslot.Count <= 0 then
										table.remove(inf.Inventory,selnum)
									end
								end
							end

							if selid == 259 then
								local t = b1
								if t and (t == 46) then
									c1:Set(pos1.X%16,pos1.Y,pos1.Z%16,0,true)
									table.insert(upCh(c2).blockdata,{Vector3.new(pos2.X%16,pos2.Y,pos2.Z%16),b2 or 0})
									table.insert(upCh(c2).events,{"sound",Vector3.new(pos1.X + .5,pos1.Y + .5,pos1.Z + .5),soundinfo.entity.tnt.primed})
									local iteme = createEntity(Vector3.new(pos1.X + .5,pos1.Y + .5,pos1.Z + .5),"tnt",c1.Dimension)
									if iteme then
										iteme.Motion = Vector3.new((math.random()-.5)*0.05,0.1,(math.random()-.5)*0.05)
										iteme.Fuse = 80
										iteme:Initialize()
									end
								else
									c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop)
								end
							elseif (selid == 324) or (selid == 330) or (selid == 489)  then
								-- lower
								local prop1 = {
									facing = prop.facing,
									hinge = prop.hinge,
									half = "lower"
								}
								c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop1)
								-- upper
								local prop2 = {
									facing = prop.facing,
									hinge = prop.hinge,
									half = "upper"
								}
								c2:Set(pos2.X%16,pos2.Y + 1,pos2.Z%16,aid,true,prop2)
							else
								c2:Set(pos2.X%16,pos2.Y,pos2.Z%16,aid,true,prop)
							end
							if (selid == 326) or (selid == 327) then
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.item.bucket.empty,i})
							elseif (selid == 259) then
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.item.flintandsteel.use,i})
							else
								table.insert(upCh(c2).events,{"sound",Vector3.new(pos2.X + .5,pos2.Y + .5,pos2.Z + .5),soundinfo.block[idinfo[aid].sound].place,i})
							end

						elseif c2 and c2.loaded then
							inf.updateInventory = true
							table.insert(upCh(c2).blockdata,{Vector3.new(pos2.X%16,pos2.Y,pos2.Z%16),b2 or 0}) -- error block
						end

					elseif state.ibreak then

						local pos = state.targetBlock
						local dist = (pos - inf.Pos).Magnitude

						local b,c = getBlock(pos.X,pos.Y,pos.Z,inf.Dimension)

						local function sendErrorBlock()
							if c and c.loaded then table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0}) end -- error block
							inf.updateInventory = true
						end

						if alive and (dist < 10) and c and c.loaded and b and (b ~= 0) then
							if inf.gamemode == 1 then
								breakBlock(i,inf,b,c,pos)
							else
								if inf.targetblock ~= pos then
									inf.breaking = nil
									inf.targethardness = nil
								end

								local hardness = (idinfo[b] and idinfo[b].hardness or math.huge)

								local harvest,speed,damage = canHarvest(selslot,b)
								if harvest then
									hardness *= 30
								else
									hardness *= 100
								end

								hardness = hardness / (speed or 1)

								if state.ibroken and ((inf.breaking or 0) > (hardness - 5)) then
									inf.breaking = nil
									inf.targetblock = nil
									if c and c.loaded and b and (b ~= 0) then
										breakBlock(i,inf,b,c,pos,harvest)
										for i,v in pairs(SpawnPoints:GetChildren()) do
											if v.Value == pos then
												v:Destroy()
											end
										end
										if selslot and (damage > 0) then
											if not selslot.tag then
												selslot.tag = {}
											end
											selslot.tag.Damage = (selslot.tag.Damage or 0) + damage
											if selslot.tag.Damage >= idinfo[selid].durability then
												selslot.tag.Damage = 0
												selslot.Count -= 1
												if selslot.Count <= 0 then
													table.remove(inf.Inventory,selnum)
													inf.updateInventory = true
												end
											end
										end
									else
										sendErrorBlock()
									end
								else
									inf.targetblock = pos
									inf.targethardness = hardness
									inf.breaking = (inf.breaking or 0) + 3

									local stage = math.min(9,math.floor(inf.breaking/hardness*10))

									table.insert(upCh(c).events,{"break",i,Vector3.new(pos.X,pos.Y,pos.Z),stage})
								end
							end
						else
							sendErrorBlock()
						end

					elseif state.iuse then

						local pos1 = state.targetBlock
						local pos2 = state.targetBlockNor and (state.targetBlock + state.targetBlockNor)
						local pos3 = state.targetFluid
						local b1,c1,prop1
						local b2,c2,prop2
						local b3,c3,prop3
						if pos1 then
							b1,c1 = getBlock(pos1.X,pos1.Y,pos1.Z,inf.Dimension)
							prop1 = b1 and indexVector(c1.propdata,pos1.X%16,pos1.Y,pos1.Z%16)
						end
						if pos2 then
							b2,c2 = getBlock(pos2.X,pos2.Y,pos2.Z,inf.Dimension)
							prop2 = b2 and indexVector(c2.propdata,pos2.X%16,pos2.Y,pos2.Z%16)
						end
						if pos3 then
							b3,c3 = getBlock(pos3.X,pos3.Y,pos3.Z,inf.Dimension)
							prop3 = b3 and indexVector(c3.propdata,pos3.X%16,pos3.Y,pos3.Z%16)
						end

						local function sendErrorBlock()
							local function rep(b,c,pos,prop)
								if b then
									if c and c.loaded then table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop}) end
								end
							end
							rep(b1,c1,pos1,prop1)
							rep(b2,c2,pos2,prop2)
							rep(b3,c3,pos3,prop3)
							inf.updateInventory = true
						end

						if selid == 325 then -- Bucket
							local pos = pos3
							local dist = (pos - inf.Pos).Magnitude
							if alive and (dist < 10) and c3 and c3.loaded and b3 and ((b3 == 9) or (b3 == 11)) then
								c3:Set(pos.X%16,pos.Y,pos.Z%16,0,true)
								table.insert(upCh(c3).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.item.bucket.fill,i})
								if selcount > 1 then
									local inside = false
									for i=0,35 do
										if not getSlotContent(getSlot(inf.Inventory,i))[2] then
											setSlot(inf.Inventory,i,{
												id = lavaid[b3] and 327 or 326,
												Count = 1
											})
											inside = true
											break
										end
									end
									if not inside then
										local iteme = createEntity(Vector3.new(inf.Pos.X,inf.Pos.Y + 1.5,inf.Pos.Z),"item",inf.Dimension)
										if iteme then
											iteme.Motion = CFrame.fromEulerAnglesYXZ(inf.Rotation.Y,inf.Rotation.X,0).LookVector*0.5
											iteme.Item = {
												Count = 1,
												id = lavaid[b3] and 327 or 326
											}
											iteme.PickupDelay = 10
											iteme:Initialize()
										end
									end
									selslot.Count = selcount - 1
								else
									selslot.id = lavaid[b3] and 327 or 326
								end
								inf.updateInventory = true

							else
								sendErrorBlock()
							end
						elseif idinfo[selid].tool and (idinfo[selid].type == "farmingtool") then -- Farming Tool
							local pos = pos1
							local dist = (pos - inf.Pos).Magnitude
							if alive and (dist < 10) and c1 and c1.loaded and b1 and ((b1 == 2) or (b1 == 3)) then
								c1:Set(pos.X%16,pos.Y,pos.Z%16,60,true)
								indexVector(c1.propdata,pos.X%16,pos.Y,pos.Z%16,{
									moisture = 0
								})
								table.insert(upCh(c1).events,{"sound",Vector3.new(pos.X + .5,pos.Y + .5,pos.Z + .5),soundinfo.block.gravel.place,i})

								if math.random(1,8) == 1 then
									local iteme = createEntity(Vector3.new(pos.X + .5,pos.Y + 1.2,pos.Z + .5),"item",inf.Dimension)
									if iteme then
										iteme.Motion = Vector3.new((math.random()-.5)*0.4,0.2,(math.random()-.5)*0.4)
										iteme.Item = {
											Count = 1,
											id = 295,
										}
										iteme.PickupDelay = 10
										iteme:Initialize()
									end
								end

								if not selslot.tag then
									selslot.tag = {}
								end
								selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
								if selslot.tag.Damage >= idinfo[selid].durability then
									selslot.tag.Damage = 0
									selslot.Count -= 1
									if selslot.Count <= 0 then
										local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
										if c and c.loaded then
											table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
										end
										table.remove(inf.Inventory,selnum)
										inf.updateInventory = true
									end
								end

							else
								sendErrorBlock()
							end

						else
							sendErrorBlock()
						end

					elseif state.iinteract then

						local pos = state.targetBlock
						local b,c = getBlock(pos.X,pos.Y,pos.Z,inf.Dimension)
						local prop
						if c then
							prop = indexVector(c.propdata,pos.X%16,pos.Y,pos.Z%16)
						end
						local dist = (pos - inf.Pos).Magnitude
						local slot =getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
						if slot and slot.Count ~= 0 then
							if 	slot.id == 405  then
								local cur = inf.Pos 
								local ent = createEntity(Vector3.new(cur.X ,cur.Y+1.5,cur.Z),"enderpearl",inf.Dimension or "overworld")
								if ent then
									ent:Initialize(inf)
								end
								slot.Count = slot.Count - 1
								inf.updateInventory = true
							end

						end
						if alive and (dist < 10) and c and c.loaded and b and (b ~= 0) then
							if (b == 2) then
								local slot =getSlot(playerinfo[i].Inventory,inf.SelectedItemSlot)
								if slot == nil or slot.Count == 0 then
									return
								end 

								if require(game.ReplicatedStorage.IDInfo)[slot.id] and require(game.ReplicatedStorage.IDInfo)[slot.id]["type"] == "shovel" then
									setBlock(pos.X,pos.Y,pos.Z,127)
									if slot == nil or slot.Count == 0 then
										return
									end
									if not slot.tag then
										slot.tag = {}
									end
									game.ReplicatedStorage.UpdatePlayer:FireClient(i,"ForceHit")
									selslot.tag.Damage = (selslot.tag.Damage or 0) + 1
									if selslot.tag.Damage > require(game.ReplicatedStorage.IDInfo)[slot.id]["durability"] then
										selslot.tag.Damage = 0
										selslot.Count = 0
										local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
										if c and c.loaded then
											table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.item["break"],i})
										end
										table.remove(inf.Inventory,selnum)
										inf.updateInventory = true
									end
									inf.updateInventory = true
								end
							end
							if (b == 69696) then
								if inf.Dimesion == "nether" then -- explode when nether xd
									createExplosion(pos,4,true,inf.Dimension)
									return
								end
								if (workspace.WorldInfo.Clock.Value >= 11000) and (workspace.WorldInfo.Clock.Value <= 21812) then
									workspace.WorldInfo.Clock.Value = 0
									local data = {
										Message = tostring(i.Character.Name.." has sleep."),
										Name = "Server",
										Color = Color3.fromRGB(252, 216, 10),
										MessageColor = Color3.fromRGB(252, 216, 10)
									}
									game.ReplicatedStorage.ServerMessage:FireAllClients(i,data,true)
								else
									local spawnpoint = game.ReplicatedStorage.SpawnPoints
									--	if not spawnpoint:FindFirstChild(i.Character.Name) then
									--	local v = Instance.new("Vector3Value",spawnpoint)
									--	v.Value = pos
									--	v.Name = i.Name
									---end
									local hasRepeatedValue = false

									for _, v in pairs(spawnpoint:GetChildren()) do
										if v.Value == pos then
											hasRepeatedValue = true
											break
										end
									end

									if not hasRepeatedValue then
										local newSpawnPoint = Instance.new("Vector3Value")
										newSpawnPoint.Name = i.Name
										newSpawnPoint.Value = pos
										newSpawnPoint.Parent = spawnpoint
									end
								end
							end

							if (b == 64) or (b == 489) and prop then
								local open = not prop.open
								prop.open = open
								c:Set(pos.X%16,pos.Y,pos.Z%16,b,true,prop)
								table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),open and soundinfo.block.wooden_door.open or soundinfo.block.wooden_door.close,i})

								local half = prop.half or "lower"
								if b == 64 then
									if half == "lower" then
										local b2 = getBlock(pos.X,pos.Y + 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y + 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y + 1,pos.Z%16,b,true,prop2)
											end
										end
									else
										local b2 = getBlock(pos.X,pos.Y - 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y - 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y - 1,pos.Z%16,b,true,prop2)
											end
										end
									end
								else
									if half == "lower" then
										local b2 = getBlock(pos.X,pos.Y + 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y + 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y + 1,pos.Z%16,489,true,prop2)
												print("set")
											end
										end
									else
										local b2 = getBlock(pos.X,pos.Y - 1,pos.Z,inf.Dimension)
										if b2 and (b2 == b) then
											local prop2 = indexVector(c.propdata,pos.X%16,pos.Y - 1,pos.Z%16)
											if prop2 then
												prop2.open = open
												c:Set(pos.X%16,pos.Y - 1,pos.Z%16,489,true,prop2)
												print("set")
											end
										end
									end
								end
							else
								table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop})
							end
						else
							table.insert(upCh(c).blockdata,{Vector3.new(pos.X%16,pos.Y,pos.Z%16),b or 0,prop})
						end

					elseif state.ieat then
						if alive and inf.Health and (plr:WaitForChild("Hunger").Value < 96) then
							if selid and idinfo[selid].food then
								if state.ieaten then
									inf.eating = nil
									selslot.Count -= 1
									if selslot.Count <= 0 then
										table.remove(inf.Inventory,selnum)
									end
									if selid == 331 then
										spawn(function()
											local v1 = game.Players:FindFirstChild(state.plrname or "None")

											if v1.Character then
												if not v1.Character:FindFirstChild("Venenous") then
													Instance.new("BoolValue",v1.Character).Name = "Venenous"
													for i = 1,math.random(3,12) do
														wait(1)
														if inf.Health > 0.51 then
															inf.Health = inf.Health - 0.5
														else
															break
														end
													end

													if v1.Character then
														inf.Health = inf.Health + 0.5
														for i,v5 in pairs(v1.Character:GetChildren()) do
															if v5.Name == "Venenous" then
																v5:Destroy()
															end
														end
													end
												end
											else
												--"Failure to load damage for rotten")
											end
										end)
									end
									if plr:WaitForChild("Hunger").Value < 96 then
										local res = 20
										if idinfo[selid].restore then
											res = idinfo[selid].restore/.25
										end
										plr:WaitForChild("Hunger").Value = plr:WaitForChild("Hunger").Value + (res or 24)
									end
									local c = getChunk(math.floor(inf.Pos.X/16),math.floor(inf.Pos.Z/16),inf.Dimension)
									if c then
										table.insert(upCh(c).events,{"sound",Vector3.new(inf.Pos.X,inf.Pos.Y + 1,inf.Pos.Z),soundinfo.entity.player.burp})
									end
									inf.updateInventory = true
									game.ReplicatedStorage.Update:FireClient(i,"RenderInventory")
								else
									inf.eating = (inf.eating or 0) + 4
								end
							else
								inf.eating = nil
							end
						else
							inf.eating = nil
						end

					end

					if state.iswing then
						addEvent(inf.Dimension,"anim",inf,0)
					end

					if inf.breaking and not state.ibreak then
						--	inf.breaking = nil
						--	inf.targethardness = nil
						--inf.targetblock = nil
					end
					if inf.eating and not state.ieat then
						inf.eating = nil
					end

					-- Events

					local tob = state.openblock
					local lob = inf.lastopenblock

					local b1,c1
					local b2,c2

					if tob then
						b1,c1 = getBlock(tob.X,tob.Y,tob.Z,inf.Dimension)
					end
					if lob then
						b2,c2 = getBlock(lob.X,lob.Y,lob.Z,inf.Dimension)
					end

					if (b1 == 54) and (b2 ~= 54) then
						table.insert(upCh(c1).events,{"chest",tob.X,tob.Y,tob.Z,true})
						table.insert(upCh(c1).events,{"sound",Vector3.new(tob.X+.5,tob.Y+.5,tob.Z+.5),soundinfo.block.chest.open})
					elseif (b1 ~= 54) and (b2 == 54) then
						table.insert(upCh(c2).events,{"chest",lob.X,lob.Y,lob.Z,false})
						table.insert(upCh(c2).events,{"sound",Vector3.new(lob.X+.5,lob.Y+.5,lob.Z+.5),soundinfo.block.chest.close})
					end

					inf.lastopenblock = tob

					inf.SelectedItem = deepcopy(selslot)

					-- Physics

					local function check()
						if (not inf.changeMotion) and (state.pos) then
							if math.sqrt((inf.Pos.X - state.pos.X)^2 + (inf.Pos.Z - state.pos.Z)^2) < 1 then
								if math.abs(inf.Pos.Y - state.pos.Y) < 4 then
									return true
								end
							end
						end
					end

					if check() then
						inf.Pos = state.pos or inf.Pos
						inf.Motion = state.motion or inf.Motion
						inf.Rotation = state.rotation or inf.Rotation
					else
						if inf and inf.Pos then
						game.ReplicatedStorage.UpdatePlayer:FireClient(plr,"Pos",inf.Pos,true)
						end
					end 


					inf.OnGround = state.onGround
				end)
			end
			
		end
	
		do local pos = state.targetBlock
			if pos then state.targetBlock = Vector3.new(math.floor(pos.X + .5),math.floor(pos.Y + .5),math.floor(pos.Z + .5)) end
		end
		do local pos = state.targetBlockNor
			if pos then state.targetBlockNor = Vector3.new(math.floor(pos.X + .5),math.floor(pos.Y + .5),math.floor(pos.Z + .5)) end
		end
		do local pos = state.targetFluid
			if pos then state.targetFluid = Vector3.new(math.floor(pos.X + .5),math.floor(pos.Y + .5),math.floor(pos.Z + .5)) end
		end

	--	statequery[plr].free = statequery[plr].free - 1

		return true,errblock and getBlock(errblock.X,errblock.Y,errblock.Z),999
	end
end


--[Initialization]

addTicket(0,0,31,"overworld")

--[Game Loop]

local gp = 0
local freq = -1000
function getTimeFromSeconds(x)
	local cv = x >= 60
	local bv = x >= 60*60
	local av = x >= 60*60*24

	local a = 0
	local b = 0
	local c = 0
	local d = 0
	a = math.floor(x / 86400)
	b = math.floor((x % 86400) / 3600)
	c = math.floor((x % 3600) / 60)
	d = math.floor(x % 60)
	local e = tostring(a)
	local f = tostring(b)
	local g = tostring(c)
	local h = tostring(d)
	if f:len() == 1 then
		f = "0" .. f
	end
	if g:len() == 1 then
		g = "0" .. g
	end
	if h:len() == 1 then
		h = "0" .. h
	end
	if av then
		return e .. ":" .. f .. ":" .. g .. ":" .. h
	elseif bv then
		return tostring(b) .. ":" .. g .. ":" .. h
	elseif cv then
		return tostring(c) .. ":" .. h
	else
		return tostring(d)
	end
end
--[
while true do
	pcall(function()
		local dt= game["Run Service"].Heartbeat:Wait()
		etst = etst + dt
		if etst >= (2/TPS) then
			gp = gp + 1
			if gp >= 20 then
				etst = etst%(1/TPS)
				gp = 0
				if (time() - freq) >= 3 then
					warn("/Craft/ server is slowing down")
					pcall(function()
						for p,v in pairs(statequery) do
						--	v.free = math.huge
						end
					end)					
					freq = time()
				end
			end
		else
			gp = math.max(0,gp - .25)
		end

		if etst >= (1/TPS) then
			etst = etst - (1/TPS)
			--etst = 0
			local ok,msg = pcall(doTick,1)
			if not ok then
				print(msg)
				for _,v in pairs(playerinfo) do
					if v and v.Parent == game.Players then
						spawnPlayer(v)
					end
				end
				etst = -2
			end
			pcall(spawn(function()
				for _,v in pairs(loadedChunks.overworld) do
					if v.generating and (getTicket(v.xPos,v.zPos,"overworld") < 34) then
						local ok = true
						local function rep(x,y)
							local c = getChunk(x,y)
							if not c then
								ok = false
								if not table.find(needChunks.overworld,Vector2.new(x,y)) then table.insert(needChunks.overworld,Vector2.new(x,y)) end
							elseif c and (genTickets.overworld[c.xPos] and genTickets.overworld[c.xPos][c.zPos]) then
								ok = false
							end
						end
						rep(v.xPos+1,v.zPos)
						rep(v.xPos,v.zPos+1)
						rep(v.xPos-1,v.zPos)
						rep(v.xPos,v.zPos-1)
						if ok then
							v.generating = false
						end
					end
					if v.loaded and not v.generating then
						local level = getTicket(v.xPos,v.zPos,"overworld")
						if level >= 35 then
							----"Compressing",v.xPos,v.zPos)
							v:Compress()
							break
						end
					end

				end
				for i=1,1 do
					local bestUnload = nil
					local bestValue2 = 34
					local bestEmpty = nil
					local bestValue = 44
					for _,v in pairs(tickets.overworld) do
						local r = 33-v.Level+(v.Radius or 0)
						if r >= 0 then
							for cx=-r,r do
								for cy=-r,r do
									local cc = getChunk(v.xPos + cx,v.zPos + cy)
									if not cc then
										local val = v.Level - (v.Radius or 0) + math.max(math.abs(cx),math.abs(cy))
										if val < bestValue then
											bestValue = val
											bestEmpty = Vector2.new(v.xPos + cx,v.zPos + cy)
										end
									elseif not cc.loaded then
										local val = v.Level - (v.Radius or 0) + math.max(math.abs(cx),math.abs(cy))
										if val < bestValue2 then
											bestValue2 = val
											bestUnload = cc
										end
									end
								end
							end
						end
					end
					for _,v in pairs(needChunks.overworld) do
						local level = getTicket(v.X,v.Y,"overworld")
						if level < bestValue then
							bestValue = level
							bestEmpty = v
						end
					end
					if bestEmpty then
						chunk.generateChunk(bestEmpty.X,bestEmpty.Y,"overworld")
						table.remove(needChunks.overworld,table.find(needChunks.overworld,bestEmpty))
					end
					if bestUnload then
						bestUnload:Load()
					end
				end

				for _,v in pairs(loadedChunks.nether) do
					if v.generating and (getTicket(v.xPos,v.zPos,"nether") < 34) then
						local ok = true
						local function rep(x,y)
							local c = getChunk(x,y,"nether")
							if not c then
								ok = false
								if not table.find(needChunks.nether,Vector2.new(x,y)) then table.insert(needChunks.nether,Vector2.new(x,y)) end
							elseif c and (genTickets.nether[c.xPos] and genTickets.nether[c.xPos][c.zPos]) then
								ok = false
							end
						end
						rep(v.xPos+1,v.zPos)
						rep(v.xPos,v.zPos+1)
						rep(v.xPos-1,v.zPos)
						rep(v.xPos,v.zPos-1)
						if ok then
							v.generating = false
						end
					end
					if v.loaded and not v.generating then
						local level = getTicket(v.xPos,v.zPos,"nether")
						if level >= 35 then
							----"Compressing",v.xPos,v.zPos)
							v:Compress()
							break
						end
					end

				end
				for i=1,1 do
					local bestUnload = nil
					local bestValue2 = 34
					local bestEmpty = nil
					local bestValue = 44
					for _,v in pairs(tickets.nether) do
						local r = 33-v.Level+(v.Radius or 0)
						if r >= 0 then
							for cx=-r,r do
								for cy=-r,r do
									local cc = getChunk(v.xPos + cx,v.zPos + cy,"nether")
									if not cc then
										local val = v.Level - (v.Radius or 0) + math.max(math.abs(cx),math.abs(cy))
										if val < bestValue then
											bestValue = val
											bestEmpty = Vector2.new(v.xPos + cx,v.zPos + cy)
										end
									elseif not cc.loaded then
										local val = v.Level - (v.Radius or 0) + math.max(math.abs(cx),math.abs(cy))
										if val < bestValue2 then
											bestValue2 = val
											bestUnload = cc
										end
									end
								end
							end
						end
					end
					for _,v in pairs(needChunks.nether) do
						local level = getTicket(v.X,v.Y,"nether")
						if level < bestValue then
							bestValue = level
							bestEmpty = v
						end
					end
					if bestEmpty then
						chunk.generateChunk(bestEmpty.X,bestEmpty.Y,"nether")
						table.remove(needChunks.nether,table.find(needChunks.nether,bestEmpty))
					end
					if bestUnload then
						bestUnload:Load("nether")
					end
				end
			end))
		end
	end)
end
--]]]
