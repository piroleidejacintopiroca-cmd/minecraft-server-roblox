-- Minecraft Server - Optimized Version
-- Features: Advanced Chunk Rendering (LOD), Efficient Pooling, Memory Optimization, Batching, Throttling, Spawning Fixes
-- Last Updated: 2026-01-06

local ServerConfig = {
	maxPlayers = 32,
	worldSize = 256,
	chunkSize = 16,
	renderDistance = 8,
	tickRate = 20,
	maxChunksPerTick = 4,
	memoryCheckInterval = 30,
	batchUpdateSize = 100,
	throttleDelay = 0.05,
}

-- ============================================================================
-- MEMORY POOL SYSTEM
-- ============================================================================
local ChunkPool = {}
ChunkPool.available = {}
ChunkPool.inUse = {}
ChunkPool.poolSize = 0
ChunkPool.maxPoolSize = 128

function ChunkPool:acquire()
	local chunk
	if #self.available > 0 then
		chunk = table.remove(self.available)
	else
		chunk = {
			blocks = {},
			entities = {},
			modified = false,
			renderData = nil,
			lodLevel = 0,
			meshes = {},
		}
		self.poolSize = self.poolSize + 1
	end
	table.insert(self.inUse, chunk)
	return chunk
end

function ChunkPool:release(chunk)
	if chunk then
		-- Clear chunk data
		table.clear(chunk.blocks)
		table.clear(chunk.entities)
		if chunk.renderData then
			chunk.renderData = nil
		end
		table.clear(chunk.meshes)
		chunk.modified = false
		chunk.lodLevel = 0
		
		-- Return to pool if below max size
		if #self.available < self.maxPoolSize then
			table.insert(self.available, chunk)
		end
	end
end

function ChunkPool:cleanup()
	if self.poolSize > self.maxPoolSize then
		local excess = self.poolSize - self.maxPoolSize
		for i = 1, excess do
			table.remove(self.available)
			self.poolSize = self.poolSize - 1
		end
	end
end

-- ============================================================================
-- LOD (LEVEL OF DETAIL) SYSTEM
-- ============================================================================
local LODSystem = {}
LODSystem.lodDistances = {0, 32, 64, 128, 256}
LODSystem.lodDetail = {1.0, 0.75, 0.5, 0.25, 0.1}

function LODSystem:calculateLOD(distance)
	for i = 1, #self.lodDistances do
		if distance <= self.lodDistances[i] then
			return i, self.lodDetail[i]
		end
	end
	return #self.lodDistances, self.lodDetail[#self.lodDistances]
end

function LODSystem:shouldRender(chunk, playerDistance)
	local lodLevel, detail = self:calculateLOD(playerDistance)
	chunk.lodLevel = lodLevel
	return detail > 0
end

-- ============================================================================
-- CHUNK MANAGER WITH OPTIMIZATIONS
-- ============================================================================
local ChunkManager = {}
ChunkManager.chunks = {}
ChunkManager.pendingUpdates = {}
ChunkManager.updateQueue = {}
ChunkManager.lastMemoryCheck = 0
ChunkManager.loadedChunkCount = 0

function ChunkManager:initChunk(x, z)
	local key = x .. "," .. z
	if self.chunks[key] then
		return self.chunks[key]
	end
	
	local chunk = ChunkPool:acquire()
	chunk.x = x
	chunk.z = z
	chunk.key = key
	
	-- Generate chunk data
	self:generateChunk(chunk)
	
	self.chunks[key] = chunk
	self.loadedChunkCount = self.loadedChunkCount + 1
	return chunk
end

function ChunkManager:generateChunk(chunk)
	-- Efficient chunk generation with pooled data structures
	for localX = 0, ServerConfig.chunkSize - 1 do
		for localZ = 0, ServerConfig.chunkSize - 1 do
			for y = 0, 255 do
				local blockType = self:getBlockType(chunk.x, y, chunk.z, localX, localZ)
				if blockType ~= 0 then
					chunk.blocks[y * 256 + localX * 16 + localZ] = blockType
				end
			end
		end
	end
	chunk.modified = true
end

function ChunkManager:getBlockType(chunkX, y, chunkZ, localX, localZ)
	-- Simplified terrain generation
	if y <= 0 then return 1 end -- Bedrock
	if y <= 60 then return 2 end -- Stone
	if y <= 62 then return 3 end -- Dirt
	if y == 63 then return 4 end -- Grass
	return 0
end

function ChunkManager:updateBlockBatch(updates)
	-- Efficient batch processing of block updates
	local batchSize = ServerConfig.batchUpdateSize
	local processed = 0
	
	for i = 1, math.min(#updates, batchSize) do
		local update = updates[i]
		self:setBlock(update.x, update.y, update.z, update.blockType)
		processed = processed + 1
	end
	
	-- Queue remaining updates
	if #updates > batchSize then
		for i = batchSize + 1, #updates do
			table.insert(self.updateQueue, updates[i])
		end
	end
	
	return processed
end

function ChunkManager:setBlock(x, y, z, blockType)
	local chunkX = math.floor(x / ServerConfig.chunkSize)
	local chunkZ = math.floor(z / ServerConfig.chunkSize)
	local key = chunkX .. "," .. chunkZ
	
	local chunk = self.chunks[key]
	if chunk then
		local localX = x % ServerConfig.chunkSize
		local localZ = z % ServerConfig.chunkSize
		chunk.blocks[y * 256 + localX * 16 + localZ] = blockType
		chunk.modified = true
	end
end

function ChunkManager:unloadChunk(x, z)
	local key = x .. "," .. z
	local chunk = self.chunks[key]
	if chunk then
		ChunkPool:release(chunk)
		self.chunks[key] = nil
		self.loadedChunkCount = self.loadedChunkCount - 1
	end
end

function ChunkManager:updateVisibleChunks(playerPos, renderDist)
	-- Throttled chunk loading/unloading
	local playerChunkX = math.floor(playerPos.x / ServerConfig.chunkSize)
	local playerChunkZ = math.floor(playerPos.z / ServerConfig.chunkSize)
	
	local loadCount = 0
	for x = playerChunkX - renderDist, playerChunkX + renderDist do
		for z = playerChunkZ - renderDist, playerChunkZ + renderDist do
			if loadCount < ServerConfig.maxChunksPerTick then
				self:initChunk(x, z)
				loadCount = loadCount + 1
			end
		end
	end
	
	-- Unload distant chunks
	for key, chunk in pairs(self.chunks) do
		local dist = math.sqrt((chunk.x - playerChunkX)^2 + (chunk.z - playerChunkZ)^2)
		if dist > renderDist + 2 then
			self:unloadChunk(chunk.x, chunk.z)
		end
	end
end

function ChunkManager:performMemoryOptimization()
	ChunkPool:cleanup()
	collectgarbage("step", 100)
end

-- ============================================================================
-- ENTITY AND SPAWN SYSTEM
-- ============================================================================
local SpawnSystem = {}
SpawnSystem.entities = {}
SpawnSystem.entityCount = 0
SpawnSystem.maxEntities = 1000
SpawnSystem.spawnQueue = {}
SpawnSystem.despawnQueue = {}

function SpawnSystem:validateSpawnLocation(x, y, z)
	-- Improved validation with safety checks
	if not x or not y or not z then
		return false, "Invalid coordinates"
	end
	
	-- Check bounds
	if y < 0 or y > 255 then
		return false, "Y coordinate out of bounds"
	end
	
	-- Check entity limit
	if self.entityCount >= self.maxEntities then
		return false, "Entity limit reached"
	end
	
	-- Check for spawn space
	local chunkX = math.floor(x / ServerConfig.chunkSize)
	local chunkZ = math.floor(z / ServerConfig.chunkSize)
	local key = chunkX .. "," .. chunkZ
	
	local chunk = ChunkManager.chunks[key]
	if not chunk then
		return false, "Chunk not loaded"
	end
	
	return true, "Success"
end

function SpawnSystem:spawnEntity(entityType, x, y, z)
	local valid, msg = self:validateSpawnLocation(x, y, z)
	if not valid then
		return nil, msg
	end
	
	local entity = {
		id = self.entityCount + 1,
		type = entityType,
		x = x,
		y = y,
		z = z,
		vx = 0,
		vy = 0,
		vz = 0,
		health = 20,
		metadata = {},
	}
	
	self.entities[entity.id] = entity
	self.entityCount = self.entityCount + 1
	
	-- Add to spawn queue for rendering
	table.insert(self.spawnQueue, entity.id)
	
	return entity, "Entity spawned successfully"
end

function SpawnSystem:despawnEntity(entityId)
	if self.entities[entityId] then
		self.entities[entityId] = nil
		self.entityCount = self.entityCount - 1
		table.insert(self.despawnQueue, entityId)
		return true
	end
	return false
end

function SpawnSystem:updateEntities(deltaTime)
	-- Process physics updates with throttling
	for id, entity in pairs(self.entities) do
		if entity then
			-- Apply gravity
			entity.vy = entity.vy - 0.1 * deltaTime
			
			-- Update position
			entity.x = entity.x + entity.vx * deltaTime
			entity.y = entity.y + entity.vy * deltaTime
			entity.z = entity.z + entity.vz * deltaTime
			
			-- Despawn if too far down
			if entity.y < -64 then
				self:despawnEntity(id)
			end
		end
	end
end

-- ============================================================================
-- ERROR HANDLING SYSTEM
-- ============================================================================
local ErrorHandler = {}
ErrorHandler.errors = {}
ErrorHandler.maxErrors = 100

function ErrorHandler:logError(context, errorMsg, severity)
	severity = severity or "WARN"
	local timestamp = os.date("%Y-%m-%d %H:%M:%S")
	
	local errorEntry = {
		timestamp = timestamp,
		context = context,
		message = errorMsg,
		severity = severity,
	}
	
	table.insert(self.errors, errorEntry)
	
	-- Maintain max size
	if #self.errors > self.maxErrors then
		table.remove(self.errors, 1)
	end
	
	print(string.format("[%s] [%s] %s: %s", timestamp, severity, context, errorMsg))
end

function ErrorHandler:wrapFunction(func, context)
	return function(...)
		local success, result = pcall(func, ...)
		if not success then
			self:logError(context, tostring(result), "ERROR")
			return nil, result
		end
		return result
	end
end

function ErrorHandler:getErrorLog()
	return self.errors
end

-- ============================================================================
-- THROTTLE SYSTEM
-- ============================================================================
local Throttler = {}
Throttler.lastExecute = {}
Throttler.throttleDelay = ServerConfig.throttleDelay

function Throttler:throttle(key, callback)
	local now = os.clock()
	if not self.lastExecute[key] or (now - self.lastExecute[key]) >= self.throttleDelay then
		self.lastExecute[key] = now
		return callback()
	end
	return nil
end

function Throttler:getExecutionTime(key)
	return self.lastExecute[key] or 0
end

-- ============================================================================
-- MAIN SERVER LOOP
-- ============================================================================
local Server = {}
Server.running = false
Server.tick = 0
Server.lastUpdate = os.clock()
Server.players = {}
Server.worldInitialized = false

function Server:initialize()
	print("Initializing Minecraft Server...")
	print("Configuration:")
	print("  Max Players: " .. ServerConfig.maxPlayers)
	print("  World Size: " .. ServerConfig.worldSize)
	print("  Chunk Size: " .. ServerConfig.chunkSize)
	print("  Render Distance: " .. ServerConfig.renderDistance)
	print("  Tick Rate: " .. ServerConfig.tickRate .. " Hz")
	
	-- Initialize spawn point chunk
	ChunkManager:initChunk(0, 0)
	self.worldInitialized = true
	
	print("Server initialized successfully!")
	self.running = true
end

function Server:update()
	if not self.running then return end
	
	local now = os.clock()
	local deltaTime = now - self.lastUpdate
	self.lastUpdate = now
	
	-- Update entities and physics
	SpawnSystem:updateEntities(deltaTime)
	
	-- Process pending block updates
	if #ChunkManager.updateQueue > 0 then
		local updates = {}
		for i = 1, math.min(ServerConfig.batchUpdateSize, #ChunkManager.updateQueue) do
			table.insert(updates, table.remove(ChunkManager.updateQueue, 1))
		end
		ChunkManager:updateBlockBatch(updates)
	end
	
	-- Update visible chunks for each player
	for _, player in pairs(self.players) do
		Throttler:throttle("chunk_update_" .. player.id, function()
			ChunkManager:updateVisibleChunks(player.position, ServerConfig.renderDistance)
		end)
	end
	
	-- Periodic memory optimization
	ChunkManager.lastMemoryCheck = ChunkManager.lastMemoryCheck + deltaTime
	if ChunkManager.lastMemoryCheck >= ServerConfig.memoryCheckInterval then
		ChunkManager.lastMemoryCheck = 0
		ChunkManager:performMemoryOptimization()
	end
	
	self.tick = self.tick + 1
end

function Server:shutdown()
	print("Shutting down server...")
	self.running = false
	
	-- Cleanup all chunks
	for key in pairs(ChunkManager.chunks) do
		local parts = string.split(key, ",")
		ChunkManager:unloadChunk(tonumber(parts[1]), tonumber(parts[2]))
	end
	
	print("Server shutdown complete!")
end

function Server:addPlayer(playerId, playerName)
	local player = {
		id = playerId,
		name = playerName,
		position = {x = 0, y = 64, z = 0},
		inventory = {},
		health = 20,
	}
	
	self.players[playerId] = player
	
	-- Spawn initial chunks around player
	ChunkManager:updateVisibleChunks(player.position, ServerConfig.renderDistance)
	
	print("Player '" .. playerName .. "' added to server")
	return player
end

function Server:removePlayer(playerId)
	self.players[playerId] = nil
	print("Player " .. playerId .. " removed from server")
end

function Server:getServerStats()
	return {
		tick = self.tick,
		players = #self.players,
		loadedChunks = ChunkManager.loadedChunkCount,
		entities = SpawnSystem.entityCount,
		pooledChunks = #ChunkPool.available,
		memoryUsage = collectgarbage("count"),
		errorCount = #ErrorHandler.errors,
	}
end

-- ============================================================================
-- PUBLIC API
-- ============================================================================
local API = {}

function API:initialize()
	Server:initialize()
end

function API:update()
	Server:update()
end

function API:shutdown()
	Server:shutdown()
end

function API:addPlayer(id, name)
	return Server:addPlayer(id, name)
end

function API:removePlayer(id)
	Server:removePlayer(id)
end

function API:spawnEntity(type, x, y, z)
	return SpawnSystem:spawnEntity(type, x, y, z)
end

function API:despawnEntity(id)
	return SpawnSystem:despawnEntity(id)
end

function API:setBlock(x, y, z, blockType)
	ChunkManager:setBlock(x, y, z, blockType)
end

function API:getServerStats()
	return Server:getServerStats()
end

function API:getErrorLog()
	return ErrorHandler:getErrorLog()
end

function API:movePlayer(playerId, x, y, z)
	local player = Server.players[playerId]
	if player then
		player.position = {x = x, y = y, z = z}
	end
end

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================
function string.split(str, delimiter)
	local result = {}
	for match in (str .. delimiter):gmatch("(.-)" .. delimiter) do
		table.insert(result, match)
	end
	return result
end

-- Export API
return API
